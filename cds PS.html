<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chico Concursos - Flashcards com Progresso</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#121212"">
  <link rel="apple-touch-icon" href="https://img.icons8.com/color/96/books.png"> 
<link rel="icon" type="image/png" href="https://img.icons8.com/color/96/books.png">
<!-- NOVA FONTE ROBOTO -->
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    * { margin:0; padding:0; box-sizing:border-box; }

/* --- MICRO-INTERAÇÕES (NOVO) --- */
button, select, .menu-item-row, .info-icon {
  transition: all 0.2s ease !important; /* Suavidade em tudo */
}
button:active, .menu-item-row:active {
  transform: scale(0.95) !important; /* Efeito de clique físico */
}
/* --- COR DOS ÍCONES (DOURADO) --- */
/* Pinta de dourado os ícones do menu, do botão hambúrguer e da barra superior */
.menu-item-row i, 
.hamburger-btn i,
.top-bar button i {
    color: #FFD700;
    text-shadow: 0 0 5px rgba(255, 215, 0, 0.3); /* Brilho suave */
}

/* Exceção: Mantém o ícone de SAIR vermelho para segurança */
.menu-item-row i.fa-sign-out-alt {
    color: #ff3333 !important;
    text-shadow: none;
}

body {
  background-color: #121212;
  color: #FFD700;
  font-family: 'Roboto', sans-serif; /* Fonte Atualizada */
  text-align: center;
  overflow-x: hidden;
}
      .top-bar {
      display: flex;
      justify-content: center;        /* ← CENTRALIZADO */
      align-items: center;
      background-color: #1e1e1e;
      padding: 5px 10px;              /* ← Aumentei levemente o padding vertical */
      flex-wrap: wrap;                /* ← ALTERADO: Agora quebra linha igual a base */
      overflow: visible;              /* ← ALTERADO: Permite que o tooltip saia da caixa */
      gap: 10px;
      white-space: nowrap;
      position: relative;             /* ← NOVO: Necessário para o z-index funcionar */
      z-index: 100;                   /* ← NOVO: Garante que fique ACIMA do cartão */
    }
    .top-bar button,
    .top-bar select {
	  min-width: 0;
      background: none;
      border: none;
      color: white;
      font-size: 1.2em;
      cursor: pointer;
      position: relative;
    }
    .top-bar span {
      font-size: 1.0em;
      color: white;
    }
	/* --- ESTILOS DO MENU HAMBÚRGUER --- */
    .hamburger-btn {
      font-size: 1.5em !important;
      padding: 5px 10px;
      cursor: pointer;
      z-index: 10006;
    }
    
    .menu-dropdown {
      display: none; /* Escondido por padrão */
      position: absolute;
      top: 100%;
      left: 10px; /* Alinhado à esquerda */
      background-color: #222;
      border: 1px solid #FFD700;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.9);
      z-index: 20000; /* Acima de tudo */
      flex-direction: column;
      gap: 12px;
      text-align: left;
      min-width: 220px;
      
      /* --- NOVAS REGRAS DE ROLAGEM --- */
      max-height: 60vh;       /* Ocupa no máximo 60% da altura da tela */
      overflow-y: auto;       /* Cria barra de rolagem se o conteúdo for maior */
      overflow-x: hidden;     /* Evita rolagem lateral */
    }

    .menu-dropdown.show-menu {
      display: flex; /* Aparece quando ativo */
      animation: slideDown 0.3s ease;
    }

    .menu-item-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 5px;
      border-bottom: 1px solid #333;
      color: white;
      text-decoration: none;
      cursor: pointer;
    }
    .menu-item-row:last-child {
      border-bottom: none;
    }
    .menu-item-row:hover {
      background-color: #333;
    }
    .menu-item-label {
      font-size: 1em;
      color: #ddd;
    }
    
    @keyframes slideDown {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
      #categoryFilter {
      background-color: #222;
      border: 1px solid #555;
      padding: 2px 4px;
      color: white;
      font-size: 1.0em;
      max-width: 180px; /* ← limite de largura para não quebrar linha */
      width: auto;
      flex-shrink: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* CORREÇÃO DAS TOOLTIPS DA BARRA SUPERIOR */
    .top-bar .tooltip {
      position: relative; /* Garante referência */
    }
    
    /* Usa a classe .show-tooltip que o JS adiciona */
    /* Usa a classe .show-tooltip que o JS adiciona - VERSÃO SLIM */
    .top-bar .tooltip.show-tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      
      /* Posicionamento (Mais colado ao botão) */
      top: 100%; 
      left: 50%;
      transform: translateX(-50%);
      margin-top: 2px; /* Pequeno respiro */
      
      /* Visual Compacto */
      background: #222;
      color: #fff;
      padding: 3px 8px; /* Reduzi de 6px para 3px (muito mais fino) */
      border-radius: 4px;
      white-space: nowrap;
      font-size: 0.75em; /* Letra levemente menor */
      line-height: 1;    /* Remove altura extra de linha */
      border: 1px solid gold; 
      box-shadow: 0 4px 10px rgba(0,0,0,0.9);
      
      z-index: 10005; 
      opacity: 1;
      visibility: visible;
    }

    /* Remove o comportamento padrão de hover do CSS antigo para evitar conflito */
    .tooltip:hover::after {
        display: none;
    }
    /* Restaura para quem tem a classe */
    .tooltip.show-tooltip::after {
        display: block;
    }
   #card-container {
      position: relative;
      background-color: white;
      color: black;
      
      /* --- AJUSTE FINAL PC: LARGURA TOTAL / ALTURA TRAVADA --- */
      width: 98%;             /* VOLTOU: Ocupa quase toda a largura da tela */
      max-width: none;        /* VOLTOU: Sem limite de largura */
      
      height: 325px;          /* MANTIDO: Altura fixa para não ficar gigante verticalmente */
      max-height: 85vh;       /* Segurança para telas de notebooks pequenos */
      margin: 0px auto;      /* Centralizado */
      
      padding: 40px 10px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      overflow-y: auto;       /* Cria barra de rolagem se o texto for maior que 600px */
      overflow-x: hidden;
      white-space: pre-wrap;
      overscroll-behavior: contain; 
    }
    #flashcard-content {
      text-align: center;
      width: 100%;
      max-height: 100%;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 10px;
      box-sizing: border-box;
      word-wrap: break-word;
    }
    .bottom-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0px 0;
      flex-wrap: wrap;
      gap: 10px;
    }
    .bottom-bar button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.4em;
      color: white;
      position: relative;
    }
    .bottom-bar button::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 120%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 0.75em;
      white-space: nowrap;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .bottom-bar button.show-tooltip::after {
      opacity: 1;
    }
    .bottom-bar input[type="number"] {
      width: 55px;
      padding: 1,5px;
      font-size: 1em;
    }
    #timer {
      cursor: pointer;
    }
    #helpModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    #helpModalContent {
      background: #222;
      color: white;
      padding: 30px;
      border-radius: 10px;
      max-width: 600px;
      width: 90%;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
      position: relative;
      max-height: 80vh;
      overflow-y: auto;
      text-align: center;
    }
    #helpModalContent h2 {
      color: gold;
      margin-bottom: 20px;
      font-size: 1.8em;
    }
    #iconLegend p {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      margin-bottom: 10px;
      font-size: 1.1em;
    }
    #iconLegend p span:first-child {
      font-size: 1.5em;
      margin-right: 15px;
      min-width: 40px;
      text-align: center;
    }
    #helpModalContent .close-button {
      background: gold;
      color: black;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 30px;
      font-size: 1.1em;
      transition: background 0.3s ease;
    }
    #helpModalContent .close-button:hover {
      background: #e5c300;
    }
	    #highlightFeedback {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 15px;
        border-radius: 8px;
        font-size: 1.5em;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.5s ease-out;
        pointer-events: none;
    }
    #autoAdvanceTimerDisplay {
      font-size: 1.0em;
      color: white;
      min-width: 40px;
      text-align: center;
    }
    #autoAdvanceSetup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #222;
        color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        z-index: 10001;
        display: none;
        flex-direction: column;
        align-items: center;
    }
    #autoAdvanceSetup h3 {
        margin-bottom: 15px;
        color: gold;
    }
    #autoAdvanceDelayInput {
        padding: 5px;
        font-size: 1em;
        width: 80px;
        text-align: center;
        margin-bottom: 15px;
        background-color: #333;
        color: white;
        border: 1px solid #555;
        border-radius: 4px;
    }
    #autoAdvanceSetup button {
        background-color: #555;
        color: white;
        border: none;
        padding: 8px 15px;
        margin: 0 5px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    #autoAdvanceSetup button:hover {
        background-color: #777;
    }
    #autoAdvanceSetup button:first-child {
        background-color: gold;
        color: black;
    }
    #autoAdvanceSetup button:first-child:hover {
        background-color: #e5c300;
    }
    #autoAdvanceOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.7);
        z-index: 10000;
        display: none;
    }
    #cardCounter {
      transition: all 0.5s ease;
      padding: 3px 10px;
      border-radius: 15px;
      background-color: rgba(0, 0, 0, 0.5);
    }
    #cardCounter.saved {
      background-color: rgba(0, 128, 0, 0.7);
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
    }
    #cardCounter .current-card {
      color: #32CD32;
      font-weight: bold;
      transition: color 0.5s ease;
    }
    #cardCounter .saved .current-card {
      color: #00FF00;
      text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);
    }
    #statsModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    #statsModalContent {
      background: #222;
      color: white;
      padding: 30px;
      border-radius: 10px;
      max-width: 600px;
      width: 90%;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
      position: relative;
      max-height: 80vh;
      overflow-y: auto;
      text-align: left;
    }
    #statsModalContent h2 {
      color: gold;
      margin-bottom: 20px;
      font-size: 1.8em;
      text-align: center;
    }
    .stats-section {
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #444;
    }
    .stats-section h3 {
      color: #FFD700;
      margin-bottom: 10px;
    }
    .card-review-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 5px;
      border-bottom: 1px solid #333;
    }
    .card-review-item:nth-child(odd) {
      background-color: rgba(255, 215, 0, 0.1);
    }
    .card-review-content {
      flex-grow: 1;
      margin-right: 15px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .card-review-time {
      color: gold;
      font-weight: bold;
      min-width: 70px;
      text-align: right;
    }
	#accuracy-results {
    display: none; /* Inicialmente oculto */
    font-size: 1.5em;
    margin-bottom: 20px; /* Espaçamento aplicado somente quando visível */
    }
    #end-screen {
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      border-radius: 10px;
      padding: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
      z-index: 10;
      text-align: center;
    }
    #end-message {
      font-size: 3em;
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
      color: #FFD700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      background: linear-gradient(45deg, #FFD700, #D4AF37);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      padding: 20px;
	  margin-bottom: 20px
    }
    #restart-button {
      background: linear-gradient(to bottom, #FFD700, #D4AF37);
      color: black;
      border: none;
      padding: 15px 30px;
      font-size: 1.2em;
      border-radius: 50px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
      transition: all 0.3s ease;
    }
    #restart-button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
    }
    #loginModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.9);
      /* Z-index MÁXIMO: Garante que o login cubra qualquer botão do sistema */
      z-index: 2147483647 !important; 
      display: flex;
      justify-content: center;
      
      /* ALTERADO: Alinha no topo em vez do centro */
      align-items: flex-start; 
      /* ADICIONADO: Empurra a caixa 100px para baixo para não colar no teto */
      padding-top: 100px; 
    }
    .login-container {
      background-color: #111;
      padding: 30px;
      border-radius: 10px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 0 20px rgba(255,215,0,0.5);
    }
    .login-container h2 {
      color: #FFD700;
      text-align: center;
      margin-bottom: 20px;
    }
    .login-form {
      display: flex;
      flex-direction: column;
    }
    .form-group {
      margin-bottom: 15px;
    }
    .form-group label {
      display: block;
      color: white;
      margin-bottom: 5px;
    }
    .form-group input {
      width: 100%;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #555;
      background-color: #222;
      color: white;
    }
    .login-button {
      width: 100%;
      padding: 12px;
      background: linear-gradient(to bottom, #FFD700, #D4AF37);
      color: black;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 10px;
      position: relative;
      transition: all 0.3s ease;
    }
    .login-button:disabled {
      opacity: 0.8;
      cursor: not-allowed;
    }
    .login-button .spinner {
      display: none;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 0, 0, 0.3);
      border-radius: 50%;
      border-top-color: black;
      animation: spin 1s ease-in-out infinite;
      position: absolute;
      left: 50%;
      top: 50%;
      margin-left: -10px;
      margin-top: -10px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #loginError {
      color: #ff5555;
      margin-top: 15px;
      text-align: center;
      display: none;
    }
    .logout-button {
      background: linear-gradient(to bottom, #ff3333, #cc0000);
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .logout-button:hover {
      background: linear-gradient(to bottom, #ff5555, #dd0000);
    }
    .loading-indicator {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10001;
      text-align: center;
    }
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(255, 215, 0, 0.3);
      border-radius: 50%;
      border-top-color: #FFD700;
      animation: spin 1s ease-in-out infinite;
      margin: 0 auto 15px;
    }
    .loading-text {
      color: #FFD700;
      font-size: 1.2em;
    }
    @keyframes pulseSuccess {
      0% { box-shadow: 0 0 5px rgba(0, 255, 0, 0.5); }
      50% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.8); }
      100% { box-shadow: 0 0 5px rgba(0, 255, 0, 0.5); }
    }
    #sessionExpiredModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.9);
      z-index: 10000;
      display: none;
      justify-content: center;
      align-items: center;
    }
    .session-expired-container {
      background-color: #111;
      padding: 30px;
      border-radius: 10px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 0 20px rgba(255,0,0,0.5);
      text-align: center;
    }
    .session-expired-container h2 {
      color: #ff5555;
      margin-bottom: 20px;
    }
    .session-expired-container p {
      color: white;
      margin-bottom: 20px;
    }
    .accuracy-button {
      font-size: 1.4em !important;
      transition: all 0.3s ease;
    }
    .accuracy-button.correct {
      color: #4CAF50 !important;
      text-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
    }
    .accuracy-button.incorrect {
      color: #F44336 !important;
      text-shadow: 0 0 10px rgba(244, 67, 54, 0.7);
    }
    .stats-tabs {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #444;
    }
    .stats-tab {
      padding: 10px 20px;
      cursor: pointer;
      background-color: #333;
      margin-right: 5px;
      border-radius: 5px 5px 0 0;
      transition: all 0.3s ease;
    }
    .stats-tab.active {
      background-color: #FFD700;
      color: black;
      font-weight: bold;
    }
    .stats-content {
      display: none;
    }
    .stats-content.active {
      display: block;
    }
    .accuracy-summary {
      text-align: center;
      margin-bottom: 20px;
    }
    .accuracy-meter {
      display: flex;
      height: 30px;
      background-color: #333;
      border-radius: 15px;
      overflow: hidden;
      margin: 15px 0;
    }
    .correct-portion {
      background-color: #4CAF50;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    .incorrect-portion {
      background-color: #F44336;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    .review-option {
      margin-top: 20px;
      padding: 10px;
      background-color: rgba(255, 215, 0, 0.1);
      border-radius: 5px;
      text-align: center;
    }
    .review-button {
      background: linear-gradient(to bottom, #FFD700, #D4AF37);
      color: black;
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      margin-top: 10px;
    }
		.highlight-asterisk {
      color: #0000FF !important;
      font-weight: bold;
    }
    .highlight-asterisk-gold {
      color: #FFD700 !important;
      font-weight: bold;
    }
	    .highlight-asterisk-alt1 { /* Fundo branco – 1ª, 3ª, 5ª... → Azul */
      color: #0000FF !important;
      font-weight: bold;
    }
    .highlight-asterisk-alt2 { /* Fundo branco – 2ª, 4ª, 6ª... → Vermelho */
      color: #ff0000 !important;
      font-weight: bold;
    }
    .highlight-asterisk-gold-alt1 { /* Fundo preto – 1ª, 3ª, 5ª... → Amarelo */
      color: #FFD700 !important;
      font-weight: bold;
    }
    .highlight-asterisk-gold-alt2 { /* Fundo preto – 2ª, 4ª, 6ª... → Verde */
      color: #89F336 !important;
      font-weight: bold;
    }
	    /* Restaurar fundo preto nos menus de cor */
    #cardColor,
    #textColor {
      background-color: #121212 !important;
      color: white !important;
      border: 1px solid #555 !important;
      padding: 2px 4px !important;
    }
	/* Estilos para o novo Modal de Configurações */
    /* === REGRA MESTRA: CORREÇÃO DE TODOS OS MODAIS (POSIÇÃO E VISIBILIDADE) === */
    /* Aplica a correção ao Configurações, Ajuda, Manual, Stats, Filtro, Reporte, etc. */
    #settingsModal, #helpModal, #manualModal, #statsModal, #filterModal, #reportModal, #handsFreeModal, #evalModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      
      /* CORREÇÃO 1: Z-Index MÁXIMO para garantir que o Configurações apareça na frente do Menu */
      z-index: 2147483647 !important; 
      
      display: flex;
      justify-content: center;
      
      /* CORREÇÃO 2: Alinha tudo no TOPO (igual ao Login) para não cortar na tela do Google Sites */
      align-items: flex-start !important; 
      padding-top: 80px !important;       /* Respiro do topo */
      padding-bottom: 50px !important;    /* Respiro do fundo */
      
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      
      /* Permite rolar se o conteúdo do modal for muito grande */
      overflow-y: auto !important; 
    }
    #settingsModalContent {
      background: #222;
      color: white;
      padding: 20px; /* Reduzi de 30px para 20px para ganhar espaço */
      border-radius: 10px;
      max-width: 600px;
      width: 90%;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
      text-align: left;
      
      /* --- CORREÇÃO DO ESTOURO --- */
      max-height: 85vh;       /* Ocupa no máximo 85% da altura da tela */
      overflow-y: auto;       /* Cria barra de rolagem SE precisar */
      display: flex;          /* Organiza o conteúdo */
      flex-direction: column; /* Em coluna */
    }
    #settingsModalContent h2 {
      color: gold;
      margin-bottom: 25px;
      font-size: 1.8em;
      text-align: center;
    }
    #settingsModalContent h3 {
      color: #FFD700;
      margin-bottom: 15px;
      border-bottom: 1px solid #444;
      padding-bottom: 8px;
    }
    .settings-section {
      margin-bottom: 20px;
    }
    .mode-selection label {
      margin-right: 20px;
      font-size: 1.1em;
    }
    .mode-selection input {
      margin-right: 5px;
    }
    #provasOptions select {
      padding: 8px;
      background-color: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      font-size: 1em;
      width: 100%;
    }
    .settings-actions {
      text-align: center;
      margin-top: 30px;
    }
    .settings-actions .start-button {
      background: linear-gradient(to bottom, #FFD700, #D4AF37);
      color: black;
      border: none;
      padding: 12px 25px;
      font-size: 1.1em;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      margin-right: 15px;
    }
    .settings-actions .close-button {
      background: #555;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1.1em;
    }
	.discipline-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .discipline-select {
      flex-grow: 1;
      padding: 8px;
      background-color: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
    }
    .quantity-input {
      width: 70px;
      padding: 8px;
      text-align: center;
      background-color: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
    }
    .add-discipline-button {
      background-color: #444;
      border: 1px solid #666;
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 5px;
    }
    .total-questions-display {
      margin-top: 15px;
      font-size: 1.1em;
      font-weight: bold;
      color: gold;
    }
	/* --- REGRAS GERAIS (PC) --- */
    /* Esconde os botões exclusivos de celular quando estiver no PC */
    /* Botão MOSTRAR RESPOSTA (Ajustado para não bloquear o Login) */
      #mobileAnswerBtn {
        /* Removemos o !important do display para o JS poder esconder no login */
        display: none; 
        position: fixed !important;
        bottom: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: auto !important;
        min-height: 65px;
        padding-bottom: max(10px, env(safe-area-inset-bottom)); 
        padding-top: 15px;
        background-color: #222 !important; 
        color: #FFD700 !important;        
        font-size: 1.3em !important;
        font-weight: bold;
        border: none !important;
        border-top: 2px solid #FFD700 !important;
        /* Z-index REDUZIDO: Alto o bastante para o card, mas menor que o Login */
        z-index: 9000 !important; 
        cursor: pointer;
        box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
      }

    /* --- REGRAS EXCLUSIVAS PARA CELULAR (LAYOUT HÍBRIDO V8) --- */
    @media (max-width: 768px) {
      
      /* === 1. TROCA INTELIGENTE DO TOPO === */
      /* Esconde o Relógio no celular */
      #desktopTimer {
          display: none !important;
      }
      /* Mostra o Botão de Voz no celular (no lugar do relógio) */
      #mobileTopTTS {
          display: inline-block !important;
          color: #FFD700 !important; /* Garante que o ícone fique dourado */
      }

      /* === 2. VISUAL "TELA CHEIA" === */
      /* === 2. VISUAL "TELA CHEIA" (CORRIGIDO PARA ROLAGEM) === */
      #card-container {
        width: 100% !important;
        /* Define altura MÍNIMA, mas deixa crescer se o texto for grande */
        min-height: calc(100vh - 120px) !important; 
        height: auto !important; 
        
        margin: 0 !important;
        border-radius: 0 !important;
        box-shadow: none !important;
        background-color: black; 
        border-bottom: 1px solid #333;
        
        display: flex;
        align-items: center; /* Centraliza verticalmente se o texto for pequeno */
        
        /* IMPORTANTE: Remove a rolagem interna e deixa a página rolar */
        overflow: visible !important; 
      }

      /* Garante que o fundo da página inteira seja preto no celular */
      body {
        background-color: #121212 !important;
        min-height: 100vh;
      }

      #flashcard-content {
        padding: 20px 15px 100px 15px !important; /* Padding extra embaixo p/ não bater no botão */
        font-size: 1.5em; 
        color: #e0e0e0; 
        line-height: 1.6;
        font-weight: 500;
        
        /* Solta o conteúdo para ocupar o espaço necessário */
        max-height: none !important; 
        overflow: visible !important;
      }
      
      #flashcard-content img {
        max-height: 50vh; /* Permite imagens maiores */
        width: auto;
        max-width: 100%;
      }
      
      #flashcard-content img {
        max-height: 40vh;
        width: auto;
      }

      /* === 3. LIMPEZA DA BARRA SUPERIOR === */
      .top-bar {
        justify-content: space-between !important;
        padding: 10px 15px !important;
        background-color: black !important;
        border-bottom: 1px solid #333;
      }
      
      /* Esconde ícones desnecessários, mas MANTÉM o nosso novo #mobileTopTTS */
      .top-bar #filterBtn, 
      .top-bar #streakDisplay,
      .top-bar button[onclick="toggleStatsModal()"],
      .top-bar button[onclick="openFilterModal()"] {
         display: none !important;
      }
      
      .menu-item-label {
          display: inline-block !important;
          color: #ddd !important;
          font-size: 1rem !important;
          opacity: 1 !important;
      }
      
      #syncIndicator { display: inline-block !important; }

      /* === 4. RODAPÉ E BOTÕES === */
      .bottom-bar { 
        display: block !important; 
        height: 0 !important; 
        padding: 0 !important;
        margin: 0 !important;
        overflow: visible !important; 
        border: none !important;
      }

      .bottom-bar > button, 
      .bottom-bar > input, 
      .bottom-bar > span,
      .bottom-bar > div:not(#srsButtons) { 
         display: none !important;
      }

      /* Botão MOSTRAR RESPOSTA */
      #mobileAnswerBtn {
        /* Reativamos o display block para celular */
        display: block !important; 
        position: fixed !important;
        bottom: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: auto !important;
        min-height: 65px;
        padding-bottom: max(10px, env(safe-area-inset-bottom)); 
        padding-top: 15px;
        background-color: #222 !important; 
        color: #FFD700 !important;        
        font-size: 1.3em !important;
        font-weight: bold;
        border: none !important;
        border-top: 2px solid #FFD700 !important;
        z-index: 2147483647 !important;
        cursor: pointer;
      }

      /* Barra SRS */
      #srsButtons {
        position: fixed !important;
        bottom: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: auto !important;
        min-height: 65px;
        padding-bottom: max(0px, env(safe-area-inset-bottom));
        background-color: #000 !important;
        z-index: 2147483647 !important;
        padding: 0 !important;
        gap: 0 !important;
        border-top: 1px solid #333;
        /* Display controlado pelo JS */
      }

      #srsButtons button.accuracy-button {
        flex: 1 !important;
        height: 70px !important;
        border-radius: 0 !important;
        margin: 0 !important;
        font-size: 0.85em !important;
        font-weight: bold;
        border: none !important;
        background-color: transparent !important;
      }

      #btnAgain, #btnDontKnow { background: #2b1515 !important; color: #ff5555 !important; border-top: 3px solid #ff5555 !important; }
      #btnHard { background: #2b2515 !important; color: #ffa500 !important; border-top: 3px solid #ffa500 !important; }
      #btnGood { background: #152b15 !important; color: #90ee90 !important; border-top: 3px solid #90ee90 !important; }
      #btnEasy { background: #152b2b !important; color: #00ff00 !important; border-top: 3px solid #00ff00 !important; }
      
      /* === AJUSTE CRÍTICO DE LOGIN MOBILE === */
      /* === AJUSTE CRÍTICO DE LOGIN MOBILE (CORREÇÃO DO LOOP) === */
      #loginModal {
        align-items: flex-start !important;
        padding-top: 20px !important;
        padding-bottom: 20px !important;
        overflow-y: auto !important;
        /* REMOVIDO O !important DAQUI PARA O JS PODER FECHAR A JANELA */
        display: flex; 
        z-index: 2147483647 !important;
      }
      
      .login-container { 
        margin: 0 auto 50px auto !important; /* Centraliza e dá espaço no fundo para rolar */
        width: 90% !important;               /* Largura segura */
        padding: 15px !important;            /* Compacta o conteúdo interno */
        max-width: 400px !important;         /* Evita que fique largo demais em tablets */
        position: relative !important;       /* Garante que o z-index funcione */
        background-color: #111 !important;   /* Fundo sólido para cobrir o que está atrás */
        box-shadow: 0 0 50px rgba(0,0,0,1) !important; /* Sombra forte para destacar */
      }

      /* Compacta os campos de input para caber mais na tela */
      .login-container .form-group {
        margin-bottom: 10px !important;
      }
      .login-container input {
        padding: 8px !important;
      }
      .login-container h2 {
        margin-bottom: 15px !important;
        font-size: 1.5em !important;
      }
    }
	/* --- ESTILO DAS CAIXAS DE SELEÇÃO (OPTION CARDS) --- */
    /* --- ESTILO LIMPO (LISTA) COM TOOLTIP --- */
    .clean-option-row {
      display: flex;
      align-items: center;
      justify-content: space-between; /* Texto na esquerda, ícone na direita */
      background: #333;
      padding: 10px 15px;
      margin-bottom: 8px;
      border-radius: 5px;
      border: 1px solid #444;
    }
    
    .clean-option-row:hover {
      background: #3a3a3a;
    }

    .clean-option-row label {
      cursor: pointer;
      flex-grow: 1; /* Clica na linha toda */
      display: flex;
      align-items: center;
      font-size: 1.1em;
    }

    .clean-option-row input[type="radio"] {
      margin-right: 10px;
      transform: scale(1.2);
    }

    /* Ícone de Ajuda (?) */
   /* --- Ícone de Ajuda (?) --- */
    .info-icon {
      cursor: help;
      font-size: 0.9em;
      color: gold;
      opacity: 0.8;
      margin-left: 10px;
      padding: 2px 7px;
      border: 1px solid #555;
      border-radius: 50%;
      position: relative; /* Necessário para segurar o tooltip */
      display: inline-block;
    }
    
    .info-icon:hover {
      opacity: 1;
      background: rgba(255, 215, 0, 0.1);
      border-color: gold;
    }

   /* --- TOOLTIP ROBUSTO (Compacto) --- */
    .info-icon:hover::after,
    .info-icon:focus::after {
      content: attr(data-tooltip);
      
      /* Visual */
      background: #222;
      color: #fff;
      border: 1px solid gold;
      border-radius: 6px;
      padding: 6px 8px;       /* Reduzido de 8px 10px */
      font-size: 0.8em;       /* Reduzido de 0.85em */
      font-weight: normal;
      line-height: 1.2;       /* Linhas mais próximas */
      text-align: left;
      white-space: normal;    /* Permite quebra de linha */
      box-shadow: 0 4px 10px rgba(0,0,0,0.8);
      
      /* Tamanho e Posição Otimizados */
      max-width: 160px;       /* Limita a largura máxima (era width: 200px fixo) */
      width: max-content;     /* A caixa só cresce o necessário para o texto */
      min-width: 100px;       /* Garante um tamanho mínimo legível */
      
      position: absolute;
      bottom: 145%;           /* Sobe um pouco mais para não tapar o ícone */
      right: -5px;            /* Alinhamento levemente ajustado */
      z-index: 10005;
      
      opacity: 1;
      visibility: visible;
      pointer-events: none;
    }

    /* Pequena seta apontando para baixo (Estético) */
    .info-icon:hover::before,
    .info-icon:focus::before {
      content: '';
      position: absolute;
      bottom: 100%; /* Logo acima do ícone */
      right: 6px;   /* Centralizado no ícone */
      border-width: 6px;
      border-style: solid;
      border-color: gold transparent transparent transparent;
      z-index: 10005;
    }
	/* --- ANIMAÇÃO DE FLIP 3D --- */
    .animate-flip {
      animation: flip-card-animation 0.4s ease-in-out;
    }

    @keyframes flip-card-animation {
      0% {
        transform: perspective(1000px) rotateY(0deg);
        opacity: 1;
      }
      50% {
        transform: perspective(1000px) rotateY(90deg);
        opacity: 0.5;
      }
      100% {
        transform: perspective(1000px) rotateY(0deg);
        opacity: 1;
      }
    }
	/* --- DESTAQUE TEMPORÁRIO DO BOTÃO DE CONFIG --- */
    .settings-highlight {
      background-color: rgba(255, 215, 0, 0.4) !important; /* Fundo Dourado Translúcido */
      box-shadow: 0 0 15px gold; /* Brilho externo */
      border-radius: 5px; /* Bordas arredondadas */
      transition: all 0.5s ease; /* Suavidade */
    }
	/* --- ALERTA PERSONALIZADO (Substitui o window.alert) --- */
    #customAlertModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 20000; /* Maior que tudo para ficar na frente */
      display: none;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(2px);
    }
    .custom-alert-box {
      background: #111;
      border: 2px solid #FFD700;
      padding: 25px;
      border-radius: 10px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
      animation: popIn 0.3s ease;
    }
    @keyframes popIn {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    .custom-alert-btn {
      background: linear-gradient(to bottom, #FFD700, #D4AF37);
      color: black;
      border: none;
      padding: 10px 25px;
      font-size: 1.1em;
      font-weight: bold;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 20px;
      min-width: 100px;
    }
    .custom-alert-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 10px gold;
    }
	/* ANIMAÇÃO DE FLASH DOS BOTÕES SRS */
    @keyframes blink-srs {
      0% { background-color: var(--blink-color); box-shadow: 0 0 15px var(--blink-color); color: black; }
      100% { background-color: transparent; box-shadow: none; color: var(--blink-color); }
    }
    .blink-active {
      animation: blink-srs 0.5s ease-out;
    }
	/* --- BARRA DE PROGRESSO --- */
    #progressBarContainer {
      width: 100%;
      height: 6px; /* Altura da barra */
      background-color: #222; /* Cor de fundo escura */
      position: relative;
      z-index: 5;
    }
    #progressBarFill {
      height: 100%;
      background: linear-gradient(90deg, #FFD700, #FFA500); /* Degradê Dourado */
      width: 0%; /* Começa em 0 */
      transition: width 0.5s ease-in-out; /* Animação suave */
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); /* Brilho */
      border-radius: 0 4px 4px 0;
    }
	/* --- FEEDBACK VISUAL (PISCAR TELA) --- */
    @keyframes flash-gold {
      0% { box-shadow: inset 0 0 0 0 transparent; }
      20% { box-shadow: inset 0 0 60px 20px rgba(255, 215, 0, 0.6); }
      100% { box-shadow: inset 0 0 0 0 transparent; }
    }
    @keyframes flash-red {
      0% { box-shadow: inset 0 0 0 0 transparent; }
      20% { box-shadow: inset 0 0 60px 20px rgba(255, 50, 50, 0.6); }
      100% { box-shadow: inset 0 0 0 0 transparent; }
    }
    .flash-success-anim {
      animation: flash-gold 0.4s ease-out;
    }
    .flash-error-anim {
      animation: flash-red 0.4s ease-out;
    }
/* --- ESTILO DO MODAL DE REPORTE --- */
    #reportModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 20000;
      display: none;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(2px);
    }
    #reportModalContent {
      background: #222;
      color: white;
      padding: 25px;
      border-radius: 10px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
      border: 1px solid #444;
      text-align: center;
    }
    #reportComment {
      width: 100%;
      padding: 10px;
      margin: 15px 0;
      border-radius: 5px;
      border: 1px solid #FFD700;
      background-color: #111;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 1em;
      resize: vertical;
    }
   /* --- CSS CORRIGIDO PARA BOTÕES DO REPORT --- */
    .report-actions {
        display: flex;
        justify-content: center;
        gap: 15px;       /* Espaço entre os botões */
        margin-top: 20px;
        width: 100%;
    }

    /* Ajuste para o botão ENVIAR dentro do reporte */
    .report-actions .custom-alert-btn {
        flex: 1;         /* Ocupa 50% do espaço */
        margin-top: 0;   /* Remove margem antiga para alinhar */
        width: auto;     /* Destrava a largura */
        padding: 12px 0; /* Altura confortável */
    }

    /* Estilo Completo para o botão CANCELAR */
    .report-actions .close-button {
        flex: 1;         /* Ocupa 50% do espaço (igual ao Enviar) */
        margin-top: 0;
        padding: 8px 0; /* Mesma altura do Enviar */
        font-size: 1.1em;
        font-weight: bold;
        border-radius: 5px;
        cursor: pointer;
        
        /* Visual: Fundo escuro com borda dourada */
        background-color: #1a1a1a; 
        border: 2px solid #444;
        color: #ccc;
        
        transition: all 0.3s ease;
    }

    /* Efeito ao passar o mouse no Cancelar */
    .report-actions .close-button:hover {
        border-color: #FFD700;
        color: #FFD700;
        background-color: #333;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
    }
	/* --- SUPORTE A IMAGENS E ZOOM --- */
    
    /* 1. Faz a imagem caber no card e parecer "clicável" */
    #flashcard-content img {
      max-width: 100%;       /* Nunca excede a largura do card */
      height: auto;          /* Mantém proporção */
      border-radius: 8px;    /* Cantos arredondados */
      margin-top: 15px;
      cursor: zoom-in;       /* Cursor de lupa */
      box-shadow: 0 4px 15px rgba(0,0,0,0.5); /* Sombra elegante */
      transition: transform 0.2s ease;
    }
    
    /* Pequeno efeito ao passar o mouse */
    #flashcard-content img:hover {
      transform: scale(1.02);
      border: 1px solid gold;
    }

    /* 2. A Janela de Zoom (Lightbox) */
    #lightboxModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95); /* Fundo bem escuro para foco */
      z-index: 25000; /* Acima de TUDO */
      display: none;
      justify-content: center;
      align-items: center;
      cursor: zoom-out; /* Cursor indica que clica para fechar */
      backdrop-filter: blur(5px);
    }

    #lightboxImage {
      max-width: 95%;
      max-height: 95vh; /* Ocupa quase toda a altura da tela */
      border: 2px solid gold;
      border-radius: 5px;
      box-shadow: 0 0 50px rgba(255, 215, 0, 0.2);
      object-fit: contain;
      animation: popIn 0.3s ease;
    }
	/* === CORREÇÃO DE ZOOM NO PC (MATA O MODO MOBILE SE TIVER MOUSE) === */
    /* Se o dispositivo tem cursor (mouse), forçamos o visual de PC */
    @media (hover: hover) {
      /* 1. Esconde o botão gigante de celular */
      #mobileAnswerBtn { display: none !important; }

      /* 2. Restaura a barra de botões do PC */
      .bottom-bar {
        display: flex !important;
        height: auto !important;
        padding: 0 !important;
        margin: 0px 0 !important;
        border: none !important;
      }

      /* 3. Garante que os botões da barra inferior apareçam */
      .bottom-bar > button, 
      .bottom-bar > input, 
      .bottom-bar > span,
      .bottom-bar > div:not(#srsButtons) {
         display: inline-block !important;
      }
      .bottom-bar > div#autoAdvanceControls {
         display: flex !important;
      }

      /* 4. Reseta a barra SRS para ficar dentro do card, não fixa no rodapé */
      #srsButtons {
        position: static !important;
        width: auto !important;
        height: auto !important;
        background-color: transparent !important;
        border-top: none !important;
        padding: 0 !important;
      }
      #srsButtons button.accuracy-button {
        height: auto !important;
        flex: none !important;
        border-radius: 5px !important;
      }

      /* 5. Ajustes finos de layout */
      #card-container {
         width: 98% !important;
         border-radius: 10px !important;
         height: 325px !important; /* Mantém altura fixa do PC */
         overflow-y: auto !important;
      }
      body {
         overflow-y: hidden !important; /* O PC rola dentro do card, não a página */
      }
      .top-bar {
         justify-content: center !important; /* Mantém o topo centralizado */
      }
    }
  </style>
</head>
<body>
<button id="mobileAnswerBtn" onclick="flipCard()" style="display:none;">MOSTRAR RESPOSTA</button>
 <div class="top-bar">
    <!-- 1. BOTÃO MENU (HAMBÚRGUER) -->
    <div style="position: relative;">
     <button class="hamburger-btn tooltip" data-tooltip="Menu Principal" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="toggleHamburgerMenu()"><i class="fas fa-bars"></i></button>
      
      <!-- GAVETA DO MENU (CONTEÚDO ESCONDIDO) -->
      <div id="mainMenuDropdown" class="menu-dropdown">
        
       <!-- Configurações e Ajuda -->
<div class="menu-item-row" onclick="toggleHelpModal(); toggleHamburgerMenu()">
    <i class="fas fa-question-circle" style="width:25px;"></i> <span class="menu-item-label">Ajuda</span>
</div>
<div class="menu-item-row" onclick="openSettingsModal(); toggleHamburgerMenu()">
    <i class="fas fa-cog" style="width:25px;"></i> <span class="menu-item-label">Configurações</span>
</div>
<div class="menu-item-row" onclick="reportCurrentCard(); toggleHamburgerMenu()">
    <i class="fas fa-exclamation-triangle" style="width:25px;"></i> <span class="menu-item-label">Reportar Erro</span>
</div>
<div class="menu-item-row" onclick="toggleManualModal(); toggleHamburgerMenu()">
    <i class="fas fa-book" style="width:25px;"></i> <span class="menu-item-label">Manual do Usuário</span>
</div>
        <!-- Aparência (Cores e Fontes) -->
<div class="menu-item-row">
    <i class="fas fa-paint-brush" style="width:25px;"></i> 
    <select id="cardColor" onchange="changeCardColor(this.value)" style="background:#000; color:white; border:1px solid #555; width:100%;">
        <option value="white">Cor do Card</option>
        <option value="white">Branco</option>
        <option value="black">Preto</option>
        <option value="darkblue">Azul Escuro</option>
        <option value="darkred">Vermelho Escuro</option>
        <option value="gold">Dourado</option>
    </select>
</div>
<div class="menu-item-row">
     <i class="fas fa-font" style="width:25px;"></i>
     <select id="textColor" onchange="changeTextColor(this.value)" style="background:#000; color:white; border:1px solid #555; width:100%;">
        <option value="black">Cor da Fonte</option>
        <option value="black">Preto</option>
        <option value="white">Branco</option>
        <option value="gold">Dourado</option>
    </select>
</div>
<div class="menu-item-row" onclick="adjustFontSize(1)">
    <i class="fas fa-plus" style="width:25px;"></i> <span class="menu-item-label">Aumentar Fonte</span>
</div>
<div class="menu-item-row" onclick="adjustFontSize(-1)">
    <i class="fas fa-minus" style="width:25px;"></i> <span class="menu-item-label">Diminuir Fonte</span>
</div>
<div class="menu-item-row" onclick="toggleHighlightAsterisks(); toggleHamburgerMenu()">
    <i class="fas fa-highlighter" style="width:25px;"></i> <span class="menu-item-label">Destacar Palavras</span>
</div>

<!-- Funcionalidades -->
<div class="menu-item-row" onclick="toggleSpeech(); toggleHamburgerMenu()">
    <span id="menuTTSIcon"><i class="fas fa-volume-up" style="width:25px;"></i></span> <span class="menu-item-label">Ler em Voz Alta</span>
</div>

        <!-- Sair -->
        <div class="menu-item-row" onclick="logout()" style="border-top: 1px solid #FFD700; margin-top:5px; padding-top:10px;">
            <i class="fas fa-sign-out-alt" style="color:red;"></i> <span class="menu-item-label" style="color:red; font-weight:bold;">Sair</span>
        </div>
      </div>
    </div>

    <!-- 2. ITENS VISÍVEIS (ESSENCIAIS) -->
    <!-- Filtro -->
    <button id="filterBtn" class="tooltip" data-tooltip="Filtrar Cards" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="openFilterModal()"><i class="fas fa-folder-open"></i></button>
    
    <span id="streakDisplay" class="tooltip" data-tooltip="Ofensiva (Dias seguidos)" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" style="color: #ff4500; font-weight: bold; cursor:default;">🔥 0</span>
	<span id="syncIndicator" class="tooltip" data-tooltip="Status: Sincronizado" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" style="color: #00ff00; font-weight: bold; cursor: help; margin-left: 8px; text-shadow: 0 0 5px #00ff00;">☁️</span>
 
    <span id="desktopTimer" class="tooltip" data-tooltip="Zerar Tempo" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="resetTimer()" style="cursor:pointer;">⏱️ <span id="timer">00:00</span></span>

    <button id="mobileTopTTS" class="tooltip" data-tooltip="Ler em Voz Alta" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="toggleSpeech()"><i class="fas fa-volume-up"></i></button>
    
    <button class="tooltip" data-tooltip="Estatísticas" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="toggleStatsModal()"><i class="fas fa-chart-line"></i></button>
    
    <button id="reviewErrorsButton" class="tooltip" data-tooltip="Revisar Erros" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="toggleReviewErrors()" style="display:none;"><i class="fas fa-search"></i></button>
  </div>
  <div id="progressBarContainer">
    <div id="progressBarFill"></div>
  </div>
  <div id="highlightFeedback"></div>
  <div id="autoAdvanceSetup">
      <h3>Tempo Automático (segundos)</h3>
      <input type="number" id="autoAdvanceDelayInput" min="1" value="5" />
      <div>
          <button onclick="confirmAutoAdvanceDelay()">OK</button>
          <button onclick="cancelAutoAdvanceDelay()">Cancelar</button>
      </div>
  </div>
  <div id="autoAdvanceOverlay" onclick="cancelAutoAdvanceDelay()"></div>
  <div id="card-container">
    <div id="flashcard-content">
      Por favor, faça login para acessar os flashcards.
    </div>
    <div id="end-screen">
      <div id="end-message">Chico Concursos<br>Fim</div>
      <button id="restart-button">RECOMEÇAR</button>
	  <div id="accuracy-results" style="font-size: 1.5em;"></div>
      <button id="review-errors-button" class="review-button" style="margin-top: 15px; display: none;">REVISAR ERROS</button>
    </div>
  </div>
  <div class="bottom-bar">
 <div id="autoAdvanceControls" style="display: flex; align-items: center; gap: 8px;">
      <button id="autoAdvanceStartBtn" class="tooltip" data-tooltip="Iniciar temporizador" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" style="font-size: 1.2em;" onclick="startAutoAdvanceSmart()">⏳</button>
      <div id="autoAdvanceActiveGroup" style="display: none; gap: 8px; align-items: center;">
        <button class="tooltip" data-tooltip="Pausar/Continuar" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="pauseOrResumeAutoAdvance()" style="font-size: 1.2em;" id="pauseResumeBtn">⏸️</button>
        <button class="tooltip" data-tooltip="Parar temporizador" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="stopAutoAdvance()" style="font-size: 1.2em;">⏹️</button>
        <button class="tooltip" data-tooltip="Resetar contagem" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="resetAutoAdvanceTimer()" style="font-size: 1.2em;">↻</button>
        <button class="tooltip" data-tooltip="Alterar tempo" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="openAutoAdvanceSettings()" style="font-size: 1.2em;">⚙️</button>
        <span id="autoAdvanceTimerDisplay" style="font-size: 1.0em; min-width: 50px; color: white;">0s</span>
      </div>
    </div>
	<input type="number" id="goToCard" placeholder="#" onchange="goToSpecificCard()" style="margin: 0 5px;" />
    <span id="cardCounter">0/0</span>
	<button id="evalMenuBtn" data-tooltip="Menu de Avaliação" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="openEvalModal()" style="color: gold; border: 1px solid #444; border-radius: 5px; padding: 0 10px; margin-right: 5px;"><i class="fas fa-bars"></i></button>
	<div id="srsButtons" style="display: none; gap: 8px; justify-content: center; align-items: center;">
        
        <button id="btnDontKnow" class="accuracy-button" data-tooltip="Revisar em 10 min" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" style="position: relative; color: #d8bfd8; border: 1px solid #d8bfd8; border-radius: 5px; font-size: 1em; padding: 0px 10px; min-width: 70px;" onclick="rateCardSRS('again', this, '#d8bfd8')">Não Sei</button>

        <button id="btnAgain" class="accuracy-button" data-tooltip="Revisar em 10 min" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" style="position: relative; color: #ff5555; border: 1px solid #ff5555; border-radius: 5px; font-size: 1em; padding: 0px 10px; min-width: 70px;" onclick="rateCardSRS('again', this, '#ff5555')">Errei</button>

        <button id="btnHard" class="accuracy-button" data-tooltip="Revisar em 2 dias" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" style="position: relative; color: #ffa500; border: 1px solid #ffa500; border-radius: 5px; font-size: 1em; padding: 0px 10px; min-width: 70px;" onclick="rateCardSRS('hard', this, '#ffa500')">Difícil</button>

        <button id="btnGood" class="accuracy-button" data-tooltip="Revisar em 4 dias" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" style="position: relative; color: #90ee90; border: 1px solid #90ee90; border-radius: 5px; font-size: 1em; padding: 0px 10px; min-width: 70px;" onclick="rateCardSRS('good', this, '#90ee90')">Bom</button>

        <button id="btnEasy" class="accuracy-button" data-tooltip="Revisar em 7 dias" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" style="position: relative; color: #00ff00; border: 1px solid #00ff00; border-radius: 5px; font-size: 1em; padding: 0px 10px; min-width: 70px;" onclick="rateCardSRS('easy', this, '#00ff00')">Fácil</button>
    </div>
    <button class="accuracy-button" data-tooltip="Acertei (Tecla 1)" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="markAsCorrect()" id="correctButton">✅</button>
    <button class="accuracy-button" data-tooltip="Errei (Tecla 2)" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="markAsIncorrect()" id="incorrectButton">❌</button>
    <button id="shuffleButton" data-tooltip="Embaralhar cartas" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="toggleShuffleMode()">🔀</button>
	<button data-tooltip="Virar Card / Anterior (Alt)" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="reviewAndRetreat()">↩️</button>
    <button data-tooltip="Voltar" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="prevCard()">⏪</button>
    <button data-tooltip="Resposta/Perg." onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="flipCard()">⬇️</button>
    <button data-tooltip="Avançar" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="nextCard()">⏩</button>
    <button id="nextAndShow" data-tooltip="Virar Card / Próximo" onmouseover="showTooltipOnHover(this)" onmouseleave="hideTooltipOnLeave(this)" onclick="reviewAndAdvance()">↪️</button>
  </div>
  <div id="helpModal" style="display:none;">
    <div id="helpModalContent">
      <h2>Ajuda - Significado dos Ícones</h2>
      <div id="iconLegend">
	    <p><span>⚙️</span> Configurações: Define o Modo de Estudo (Simulado, SRS, Provas), Pesos e Voz.</p>
        <p><span>⚠️</span> Reportar Erro: Abre uma janela para informar falhas no card sem parar o estudo.</p>
        <p><span>🗣️</span> Ler em Voz Alta: Liga/Desliga a leitura automática do texto (Atalho removido da tecla S).</p>
        <p><span>🖌️</span> Cor do cartão: Altera a cor de fundo do flashcard.</p>
        <p><span>🔤</span> Cor da fonte: Altera a cor do texto do flashcard.</p>
        <p><span>A+</span> Aumentar fonte: Aumenta o tamanho da letra do flashcard.</p>
        <p><span>A-</span> Diminuir fonte: Diminui o tamanho da letra do flashcard.</p>
        <p><span>⏱️</span> Tempo de revisão: Exibe o tempo decorrido e zera ao clicar.</p>
        <p><span>📈</span> Estatísticas: Mostra seu desempenho and cards para revisão.</p>
        <p><span>📂</span> Categoria: Filtra os cards por categoria.</p>
        <p><span>🔍</span> Revisar Erros: Filtra apenas os cards marcados como erro.</p>
		<p><span>✨</span> Cor destaque: Muda a cor dos termos entre astériscos, fundo preto-cor dourado, fundo branco-cor azul.</p>
        <p><span>✅</span> Acertei: Marca o card atual como respondido corretamente.</p>
        <p><span>❌</span> Errei: Marca o card atual como respondido incorretamente.</p>
        <p><span>⏪</span> Voltar: Navega para o card anterior.</p>
        <p><span>↩️</span> Virar Card / Anterior: Vira o card se na resposta, retrocede se na pergunta (tecla Alt).</p>
        <p><span>🔀</span> Embaralhar cartas: Reorganiza aleatoriamente a ordem dos flashcards.</p>
        <p><span>⬇️</span> Resposta/Perg.: Vira o flashcard para mostrar a resposta (ou pergunta).</p>
        <p><span>⏩</span> Avançar: Navega para o próximo card.</p>
        <p><span>↪️</span> Virar Card / Próximo: Vira o card se na pergunta, avança se na resposta (enter).</p>
        <p><span>⏳</span> Iniciar/Parar Temporizador: Avança automaticamente para o próximo card após um tempo definido.</p>
        <p><span>Enter</span> Tecla Enter: Vira o card se na pergunta, avança se na resposta (mesma ação do botão ↪️).</p>
		<p><span>Alt</span> Virar Card / Anterior: Vira o card se na resposta, retrocede se na pergunta (tecla Alt).</p>
    <p><span>1</span> Tecla 1: Marca o card como acerto.</p>
    <p><span>2</span> Tecla 2: Marca o card como erro.</p>
        <p><span>💚</span> Indicador Verde: O número em verde mostra que seu progresso foi salvo.</p>
        <p><span>🚪</span> Sair: Encerra a sessão atual e retorna à tela de login.</p>
        <p><span>🏁</span> Tela Final: Exibida quando todos os flashcards são revisados.</p>
      </div>
      <button class="close-button" onclick="toggleHelpModal()">Fechar</button>
    </div>
  </div>
  <div id="manualModal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 9999; justify-content: center; align-items: center; backdrop-filter: blur(5px);">
    <div id="manualModalContent" style="background: #222; color: white; padding: 30px; border-radius: 10px; max-width: 700px; width: 90%; box-shadow: 0 0 30px rgba(255, 215, 0, 0.7); position: relative; max-height: 85vh; overflow-y: auto; text-align: left;">
      <h2 style="color: gold; margin-bottom: 20px; text-align: center; border-bottom: 1px solid #444; padding-bottom: 10px;">Manual do Usuário</h2>
      
      <h3 style="color: #FFD700;">📖 Como Usar</h3>
      <p style="margin-bottom: 15px;">Bem-vindo ao Chico Concursos! Este sistema utiliza repetição espaçada e inteligência artificial para otimizar seu estudo.</p>
      <ul style="margin-bottom: 20px; padding-left: 20px; line-height: 1.6;">
          <li><strong>Modos de Estudo:</strong> Escolha entre Simulado, Estudo Livre, SRS (Repetição Espaçada) ou Provas nas configurações.</li>
          <li><strong>Inteligência Artificial:</strong> O "Modo Foco" detecta suas dificuldades e repete os temas necessários automaticamente.</li>
          <li><strong>Gestos (Celular):</strong> Deslize o dedo para a <strong>Direita</strong> (Acertei) ou para a <strong>Esquerda</strong> (Errei/Repetir).</li>
         <li>
              <strong>Áudio (TTS):</strong> Ative a leitura em voz alta no menu ou pela tecla 'S'. Você pode escolher a velocidade e a voz nas configurações.
              <div style="margin-top: 8px; margin-bottom: 8px; background: rgba(0, 120, 215, 0.2); border: 1px solid #0078d7; padding: 10px; border-radius: 5px; font-size: 0.95em; color: #e1f0ff;">
                  <strong>💡 Dica de Ouro:</strong> Para uma experiência superior, recomendamos usar o navegador <strong>Microsoft Edge</strong>. Ele possui vozes neurais ultra-realistas (quase humanas) que já vêm instaladas nativamente.
              </div>
          </li>
		  <li><strong>Sanguessugas:</strong> Se errar o mesmo card 5 vezes, o sistema alerta para que você revise a teoria.</li>
          <li><strong>Filtros:</strong> Use o ícone da pasta (📂) para estudar apenas uma disciplina ou tópico específico.</li>
      </ul>

      <h3 style="color: #FFD700;">⌨️ Teclas de Atalho</h3>
      <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">Enter</td><td style="padding: 8px;">Virar Card / Avançar</td></tr>
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">Alt</td><td style="padding: 8px;">Voltar Card Anterior</td></tr>
          
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">1</td><td style="padding: 8px;">Acertei (Normal) / Errei (SRS)</td></tr>
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">2</td><td style="padding: 8px;">Errei (Normal) / Difícil (SRS)</td></tr>
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">3</td><td style="padding: 8px;">Bom (Apenas Modo SRS)</td></tr>
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">4</td><td style="padding: 8px;">Fácil (Apenas Modo SRS)</td></tr>

          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">R</td><td style="padding: 8px;">Resetar Temporizador</td></tr>
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">T</td><td style="padding: 8px;">Configurar Tempo (Timer)</td></tr>
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">P</td><td style="padding: 8px;">Pausar Temporizador</td></tr>

          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">S</td><td style="padding: 8px;">Ler em Voz Alta (On/Off)</td></tr>
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">+ (Mais)</td><td style="padding: 8px;">Aumentar Fonte</td></tr>
          <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">- (Menos)</td><td style="padding: 8px;">Diminuir Fonte</td></tr>
		  <tr style="border-bottom: 1px solid #444;"><td style="padding: 8px; color: gold;">* (Asterisco)</td><td style="padding: 8px;">Destacar Palavras</td></tr>
      </table>

      <div style="text-align: center; margin-top: 20px;">
        <button onclick="toggleManualModal()" style="background: gold; color: black; border: none; padding: 10px 25px; border-radius: 5px; font-weight: bold; cursor: pointer;">Entendi</button>
      </div>
    </div>
  </div>
  <div id="statsModal" style="display:none;">
    <div id="statsModalContent">
      <h2>Estatísticas de Estudo</h2>
      
      <div class="stats-tabs">
        <div class="stats-tab active" onclick="changeStatsTab('time')">Tempo por Card</div>
        <div class="stats-tab" onclick="changeStatsTab('accuracy')">Acertos</div>
      </div>
      
      <div class="stats-content active" id="timeStats">
        <div class="stats-section">
          <h3>Último Acesso</h3>
          <p id="lastAccessDate">Carregando...</p>
        </div>
        <div class="stats-section">
          <h3>Resumo de Desempenho</h3>
          <p id="performanceSummary">Carregando...</p>
        </div>
        <div class="stats-section">
          <h3>Cards para Revisão</h3>
          <p>Baseado no seu tempo de resposta</p>
          <div id="reviewCardsList"></div>
        </div>
      </div>
      
      <div class="stats-content" id="accuracyStats">
        <div class="stats-section">
          <h3>Desempenho de Acertos</h3>
          <div class="accuracy-summary">
            <p>Total de cards: <span id="totalCardsCount">0</span></p>
            <p>Acertos: <span id="correctCount">0</span> | Erros: <span id="incorrectCount">0</span></p>
            <div class="accuracy-meter">
              <div class="correct-portion" id="correctMeter" style="width: 0%">0%</div>
              <div class="incorrect-portion" id="incorrectMeter" style="width: 0%">0%</div>
            </div>
            <p>Taxa de acerto: <span id="accuracyRate">0%</span></p>
          </div>
        </div>
        <div class="stats-section">
          <h3>Cards com Erro</h3>
          <p>Estes são os cards que você marcado como incorretos:</p>
          <div id="incorrectCardsList"></div>
        </div>
        <div class="review-option">
          <p>Quer revisar apenas os cards que errou?</p>
          <button class="review-button" onclick="reviewIncorrectCards(); toggleStatsModal();">Revisar Cards com Erro</button>
        </div>
      </div>
      
      <button class="close-button" onclick="toggleStatsModal()">Fechar</button>
    </div>
  </div>
  <!-- INÍCIO DO NOVO MODAL DE CONFIGURAÇÕES (COLE AQUI) -->
  <div id="settingsModal" style="display:none;">
    <div id="settingsModalContent">
      <h2 style="margin-top:0; margin-bottom: 15px;">Configurações de Estudo</h2>
      
      <div class="settings-section">
        <h3>1. Escolha o Modo de Estudo</h3>
        <div class="mode-selection">
          
          <div class="clean-option-row">
            <label>
              <input type="radio" name="studyMode" value="simulado" onchange="switchStudyMode(this.value)"> 
              Simulado Personalizado
            </label>
           <span class="info-icon" tabindex="0" data-tooltip="Você escolhe as disciplinas e a quantidade exata. Ideal para focar.">?</span>
          </div>

          <div class="clean-option-row">
            <label>
              <input type="radio" name="studyMode" value="livre" onchange="switchStudyMode(this.value)"> 
              Estudo Livre
            </label>
           <span class="info-icon" tabindex="0" data-tooltip="Sorteio aleatório de todas as matérias. Você define apenas o total.">?</span>
          </div>
<div class="clean-option-row">
            <label>
              <input type="radio" name="studyMode" value="srs" onchange="switchStudyMode(this.value)"> 
              Repetição Espaçada (SRS) 🧠
            </label>
           <span class="info-icon" tabindex="0" data-tooltip="Sistema inteligente que agenda revisões. Você avalia a dificuldade e o sistema decide quando o card volta.">?</span>
          </div>
          <div class="clean-option-row">
            <label>
              <input type="radio" name="studyMode" value="provas" onchange="switchStudyMode(this.value)"> 
              Provas Anteriores
            </label>
           <span class="info-icon" tabindex="0" data-tooltip="Refaça provas completas filtradas pelo ano de aplicação.">?</span>
          </div>

        </div>
      </div>

      <div id="simuladoOptions" class="settings-section" style="display: none;">
        <h3>2. Monte seu Simulado</h3>
        <div id="simuladoLoading" style="display: none; color: gold; margin-bottom: 10px;">Carregando disciplinas...</div>
        <div id="simuladoDisciplineInputs">
          <div class="discipline-row">
            <select class="discipline-select" onchange="updateTotalQuestions()">
              <option value="">Selecione a Disciplina</option>
            </select>
            <input type="number" class="quantity-input" placeholder="Qtd" min="1" onchange="updateTotalQuestions()" onkeyup="updateTotalQuestions()">
          </div>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
            <button class="add-discipline-button" onclick="addDisciplineRow()">+ Disciplina</button>
            <p class="total-questions-display" style="margin:0;">Total: <span id="totalSimuladoQuestions">0</span></p>
        </div>
      </div>

      <div id="livreOptions" class="settings-section" style="display: none;">
        <h3>2. Configuração Rápida</h3>
        <div style="background: #333; padding: 15px; border-radius: 8px; display: flex; align-items: center; justify-content: space-between;">
            <label for="livreQuantity" style="font-size: 1.1em; color: gold;">Quantas questões?</label>
            <input type="number" id="livreQuantity" class="quantity-input" value="20" min="1" style="width: 80px; font-size: 1.3em; font-weight: bold;">
        </div>
      </div>

      <div id="provasOptions" class="settings-section" style="display: none;">
        <h3>2. Filtro para Provas</h3>
        <label for="provasAno">Escolha o Ano:</label>
        <select id="provasAno" style="width: 100%; padding: 8px; margin-top: 5px;">
          <option value="todos">Todos os Anos</option>
        </select>
      </div>

      <div class="settings-section">
	  <div class="settings-section">
        <h3>2.5. Configuração de Voz (TTS)</h3>
        <div style="margin-bottom: 15px; background: rgba(0, 120, 215, 0.25); border-left: 4px solid #0078d7; padding: 10px; border-radius: 4px;">
            <p style="margin: 0; font-size: 0.95em; line-height: 1.4;">
                🚀 <strong>Melhor Qualidade:</strong> O navegador <strong>Microsoft Edge</strong> oferece as melhores vozes (Neurais) gratuitamente. Se estiver em outro navegador, as vozes podem soar robóticas.
            </p>
        </div>
        <label style="display:block; color:gold; margin-bottom:5px;">🗣️ Voz da Pergunta (Frente):</label>
        <select id="voiceSelectQuestion" style="width:100%; padding:8px; background:#333; color:white; border:1px solid #555; border-radius:4px; margin-bottom:10px;">
            <option value="">Carregando vozes...</option>
        </select>

        <label style="display:block; color:gold; margin-bottom:5px;">🗣️ Voz da Resposta (Verso):</label>
        <select id="voiceSelectAnswer" style="width:100%; padding:8px; background:#333; color:white; border:1px solid #555; border-radius:4px; margin-bottom:10px;">
            <option value="">Carregando vozes...</option>
        </select>

        <label style="display:block; color:gold; margin-bottom:5px;">Velocidade de Leitura: <span id="rateValue">1.1x</span></label>
        <input type="range" id="rateRange" min="0.5" max="3" step="0.1" value="1.1" style="width:100%; accent-color:gold;" oninput="document.getElementById('rateValue').textContent = this.value + 'x'">
      </div>
        <h3>3. Inteligência e Pesos</h3>
        
        <div style="margin-bottom: 15px; background: rgba(255,215,0,0.1); padding: 10px; border-radius: 5px; display: flex; align-items: center; justify-content: space-between;">
            <label style="cursor: pointer; display: flex; align-items: center; flex-grow: 1;">
                <input type="checkbox" id="enableFocusMode" style="transform: scale(1.3); margin-right: 10px;"> 
                <span style="color: gold; font-weight: bold;">ATIVAR MODO FOCO 🧠</span>
            </label>
            <span class="info-icon" tabindex="0" data-tooltip="O sistema identifica automaticamente onde você tem dificuldade e manda mais questões desse assunto.">?</span>
        </div>
<div class="clean-option-row">
            <label>
              <input type="radio" name="weightMode" value="sequencial" onchange="switchWeightMode(this.value)"> 
              Sequencial (Livre)
            </label>
            <span class="info-icon" tabindex="0" data-tooltip="Mantém a ordem original da planilha ou a ordem definida pelo SRS. Não embaralha.">?</span>
          </div>
          <div class="clean-option-row">
            <label>
              <input type="radio" name="weightMode" value="ponderado" onchange="switchWeightMode(this.value)"> 
              Aleatório Ponderado
            </label>
            <span class="info-icon" tabindex="0" data-tooltip="Questões com maior peso (importância) aparecem mais vezes.">?</span>
          </div>

          <div class="clean-option-row">
            <label>
              <input type="radio" name="weightMode" value="minimo" onchange="switchWeightMode(this.value)"> 
              Peso Mínimo
            </label>
            <span class="info-icon" tabindex="0" data-tooltip="Ignora questões fáceis. Só mostra questões com peso acima do definido.">?</span>

        </div>
        
        <div id="pesoMinimoOptions" style="display: none; margin-top: 10px; padding-left: 5px;">
          <label for="pesoMinimoValue">Peso mínimo exigido:</label>
          <input type="number" id="pesoMinimoValue" class="quantity-input" min="1" value="1" style="width: 60px; margin-left: 10px;">
        </div>
      </div>

      <div class="settings-actions">
        <button id="startStudyBtn" class="start-button" onclick="startCustomStudy()">INICIAR</button>
        <button class="close-button" onclick="closeSettingsModal()">Fechar</button>
      </div>
    </div>
	</div>
  <!-- FIM DO NOVO MODAL DE CONFIGURAÇÕES -->
  <div id="filterModal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; justify-content: center; align-items: center;">
    <div id="filterModalContent" style="background: #222; color: white; padding: 25px; border-radius: 10px; max-width: 400px; width: 90%; box-shadow: 0 0 30px rgba(255, 215, 0, 0.7); text-align: center; border: 1px solid #444; max-height: 90vh; overflow-y: auto;">
      
      <h2 style="color: gold; margin-bottom: 20px; border-bottom: 1px solid #444; padding-bottom: 10px;">Filtrar Cards</h2>

      <div style="margin-bottom: 15px; text-align: left;">
        <label style="display:block; color: gold; margin-bottom: 5px; font-weight: bold;">1. Disciplina</label>
        <select id="modalDisciplineSelect" onchange="modalHandleDisciplineChange(this.value)" style="width: 100%; padding: 12px; background: #333; color: white; border: 1px solid #555; border-radius: 5px; font-size: 1.1em;">
          <option value="">Selecione...</option>
        </select>
      </div>

      <div id="modalTopicContainer" style="margin-bottom: 15px; text-align: left; display: none;">
        <label style="display:block; color: gold; margin-bottom: 5px; font-weight: bold;">2. Tópico</label>
        <select id="modalTopicSelect" onchange="modalHandleTopicChange(this.value)" style="width: 100%; padding: 12px; background: #333; color: white; border: 1px solid #555; border-radius: 5px; font-size: 1.1em;">
          <option value="todos">Todos os Tópicos</option>
        </select>
      </div>

      <div id="modalFocoContainer" style="margin-bottom: 25px; text-align: left; display: none;">
        <label style="display:block; color: gold; margin-bottom: 5px; font-weight: bold;">3. Foco Específico</label>
        <select id="modalFocoSelect" style="width: 100%; padding: 12px; background: #333; color: white; border: 1px solid #555; border-radius: 5px; font-size: 1.1em;">
          <option value="todos">Todos os Focos</option>
        </select>
      </div>

      <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px; flex-direction: column;">
        <button onclick="applyModalFilter()" style="background: linear-gradient(to bottom, #FFD700, #D4AF37); color: black; border: none; padding: 12px; font-weight: bold; border-radius: 5px; cursor: pointer; font-size: 1.1em;">APLICAR FILTRO</button>
        
        <button onclick="clearAndCloseFilter()" style="background: #444; color: white; border: 1px solid #666; padding: 10px; border-radius: 5px; cursor: pointer;">Limpar Filtros (Ver Tudo)</button>
        
        <button onclick="closeFilterModal()" style="background: transparent; border: none; color: #888; margin-top: 5px; cursor: pointer; text-decoration: underline;">Cancelar</button>
      </div>
    </div>
  </div>
  
  <div id="loginModal" style="display: flex;">
    <div class="login-container">
      <h2><i class="fas fa-lock"></i> Acesso aos Flashcards</h2>
      <form id="loginForm" class="login-form">
        <div class="form-group">
          <label for="loginEmail">Email:</label>
          <input type="email" id="loginEmail" value="@teste" readonly style="background-color: #333; color: #aaa; cursor: not-allowed;">
        </div>
        <div class="form-group">
          <label for="loginPassword">Senha:</label>
          <input type="password" id="loginPassword" value="10" readonly style="background-color: #333; color: #aaa; cursor: not-allowed;">
        </div>
        <button type="submit" class="login-button" id="loginSubmitBtn">
          <span id="loginBtnText">Acessar</span>
          <div class="spinner" id="loginSpinner"></div>
        </button>
      </form>
      <div id="loginError"></div>
    </div>
  </div>
  <div class="loading-indicator" id="loadingIndicator">
    <div class="loading-spinner"></div>
    <div class="loading-text">Carregando flashcards...</div>
  </div>
  <div id="sessionExpiredModal" style="display:none;">
    <div class="session-expired-container">
      <h2><i class="fas fa-exclamation-triangle"></i> Sessão Expirada</h2>
      <p>Sua sessão expirou devido à inatividade. Por favor, faça login novamente.</p>
      <button class="login-button" onclick="location.reload()">Fazer Login Novamente</button>
    </div>
  </div>
  <div id="reportModal">
    <div id="reportModalContent">
      <h3 style="color: #FFD700; margin-bottom: 10px;">⚠️ Reportar Erro</h3>
      <p>O que há de errado com este card?</p>
      
      <textarea id="reportComment" rows="4" placeholder="Ex: Erro de português, Gabarito errado, Lei desatualizada..."></textarea>
      
      <div class="report-actions">
        <button class="custom-alert-btn" onclick="submitReport()">ENVIAR</button>
        <button class="close-button" onclick="closeReportModal()">Cancelar</button>
      </div>
    </div>
  </div>
  <div id="lightboxModal" onclick="closeLightbox()">
    <img id="lightboxImage" src="" alt="Zoom">
    <p style="position: absolute; bottom: 20px; color: #888; font-size: 0.9em;">Toque em qualquer lugar para fechar</p>
  </div>
  <div id="customAlertModal">
    <div class="custom-alert-box">
      <h3 style="color: #FFD700; margin-bottom: 15px; font-size: 1.5em;">⚠️ Atenção</h3>
      <p id="customAlertMessage" style="color: white; font-size: 1.1em; line-height: 1.5;">Mensagem aqui</p>
      <button class="custom-alert-btn" onclick="closeCustomAlert()">OK</button>
    </div>
  </div>
  <div id="evalModal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 21000; justify-content: center; align-items: center; backdrop-filter: blur(5px);">
    <div style="background: #222; color: white; padding: 25px; border-radius: 10px; max-width: 350px; width: 90%; border: 1px solid gold; text-align: center; box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);">
      <h3 style="color: gold; margin-bottom: 20px;">Escolha a Avaliação</h3>
      
      <button onclick="setEvalMode('normal')" style="width: 100%; padding: 12px; margin-bottom: 10px; background: #333; color: white; border: 1px solid #555; border-radius: 5px; font-size: 1.1em; cursor: pointer;">
        ✅ Certo / Errado
      </button>

      <button onclick="setEvalMode('srs')" style="width: 100%; padding: 12px; margin-bottom: 10px; background: #333; color: white; border: 1px solid #555; border-radius: 5px; font-size: 1.1em; cursor: pointer;">
        🧠 SRS (Repetição Espaçada)
      </button>

      <button onclick="setEvalMode('hidden')" style="width: 100%; padding: 12px; margin-bottom: 20px; background: #444; color: #aaa; border: 1px solid #555; border-radius: 5px; font-size: 1.1em; cursor: pointer;">
        ⛔ Limpar Botões (Ocultar)
      </button>

      <button onclick="closeEvalModal()" style="background: transparent; border: none; color: gold; font-weight: bold; cursor: pointer; text-decoration: underline;">
        Fechar
      </button>
    </div>
  </div>
  <div id="handsFreeModal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 22000; justify-content: center; align-items: center; backdrop-filter: blur(5px);">
  <div style="background: #222; color: white; padding: 25px; border-radius: 10px; max-width: 400px; width: 90%; border: 1px solid #FFD700; box-shadow: 0 0 30px rgba(255, 215, 0, 0.4); text-align: center;">
    
    <div id="hfStep1">
      <h3 style="color: #FFD700; margin-bottom: 15px;">Modo de Leitura 🗣️</h3>
      <p style="margin-bottom: 20px; font-size: 1.1em;">Deseja ativar o avanço automático (Mãos Livres)?</p>
      
      <button onclick="showHfStep2()" style="background: linear-gradient(to bottom, #FFD700, #D4AF37); color: black; border: none; padding: 12px 20px; font-weight: bold; border-radius: 5px; cursor: pointer; width: 100%; margin-bottom: 10px;">
        SIM (Automático)
      </button>
      
      <button onclick="startManualTTS()" style="background: #333; color: white; border: 1px solid #555; padding: 12px 20px; border-radius: 5px; cursor: pointer; width: 100%;">
        NÃO (Apenas Ler)
      </button>
      <div style="margin-top:15px; cursor:pointer; color:#888; text-decoration:underline;" onclick="closeHandsFreeModal()">Cancelar</div>
    </div>

    <div id="hfStep2" style="display:none;">
      <h3 style="color: #FFD700; margin-bottom: 15px;">⏱️ Tempo de Espera</h3>
      <p style="margin-bottom: 10px;">Quantos segundos esperar após a resposta?</p>
      
      <input type="number" id="hfDelayInput" value="3" min="1" max="60" style="width: 80px; padding: 10px; font-size: 1.5em; text-align: center; border-radius: 5px; border: 1px solid gold; background: #000; color: white; margin-bottom: 20px;">
      
      <button onclick="startHandsFreeTTS()" style="background: linear-gradient(to bottom, #FFD700, #D4AF37); color: black; border: none; padding: 12px 20px; font-weight: bold; border-radius: 5px; cursor: pointer; width: 100%;">
        INICIAR
      </button>
      <div style="margin-top:15px; cursor:pointer; color:#888; text-decoration:underline;" onclick="resetHfModal()">Voltar</div>
    </div>

  </div>
</div>
  <script>
    // --- CONFIGURAÇÃO INICIAL ---
// --- CONFIGURAÇÃO INICIAL ---
    let WEB_APP_URL = "https://script.google.com/macros/s/AKfycbxfeIybUQvl-cb_VEBITzKF9Nbw97FgWMGWVF6pW-McV5MwVpJOoytWcVKl5dIApOjGZw/exec";
    let SRS_BACKEND_URL = "https://script.google.com/macros/s/AKfycbxy_sanjZc0AL-kMIu5LJEqjrFLAVeHIJsWtQq_l5XEqOR5E38xsOzJyHzprjJCHh15/exec"; // NOVO BACKEND
    let isAuthenticated = false;
    let userEmail = '';
	let userAllowedCourses = []; // Nova variável: armazena os IDs de planilhas que o usuário pode acessar
    let initialCards = [];
    let cards = [];
    let currentCard = 0;
    let showingFront = true;
    // Se for celular (tela pequena), usa fonte 14. Se for PC, mantém 22
    let fontSize = window.innerWidth < 768 ? 14 : 22;
    let timerSeconds = 0;
    const timerElement = document.getElementById("timer");
    const cardContainer = document.getElementById("card-container");
    const cardCounter = document.getElementById("cardCounter");
    const helpModal = document.getElementById("helpModal");
    let isShuffleActive = false;
	let currentCardColor = 'white'; // Cor padrão
    let currentTextColor = 'black'; // Cor padrão
	let isHighlightModeActive = false;
    // Variáveis para o Temporizador Automático
    let autoAdvanceInterval = null;
    let autoAdvanceSeconds = 0;
    let autoAdvanceDelay = 5;
    let isAutoAdvanceActive = false;

    const autoAdvanceTimerDisplay = document.getElementById("autoAdvanceTimerDisplay");
    // Variáveis para estatísticas
    let cardResponseTimes = {};
    let lastAccessDate = null;
    // Estado para controlar se chegou ao fim
    let isFinished = false;
    // Variáveis para categorias
    let categories = [];
    let currentCategory = "Todas";
	// Variável para lembrar o último filtro usado
    let lastFilterSelections = { discipline: "", topic: "", foco: "" };
    let cardViewStartTime = 0;
    let isAutoAdvancePaused = false;
	// --- VARIÁVEIS DO APRENDIZADO ADAPTATIVO ---
    let userLearningStats = {
        totalCharsRead: 0,
        totalTimeRead: 0,
        topicWeights: {} // Ex: { "Direito Const": 2, "Português": 1 }
    };
    // -------------------------------------------
let lastAutoAdvanceDelay = localStorage.getItem('lastAutoAdvanceDelay') 
  ? parseInt(localStorage.getItem('lastAutoAdvanceDelay'), 10) 
  : 0;

    // Variáveis para controle de expiração de sessão
    const SESSION_DURATION = 3 * 60 * 60 * 1000;
    let sessionTimer = null;

    // Variáveis para controle de acertos/erros
    let cardAccuracy = {};
    let isReviewErrorsMode = false;
    let loadedSettingsCards = []; // NOVA VARIÁVEL

    // Função para verificar autenticação e sessão
    function requireAuth() {
      if (!isAuthenticated) {
        return false;
      }
      if (isSessionExpired()) {
        expireSession();
        return false;
      }
      return true;
    }

    // Função para resetar a UI após logout
  // Função para resetar a UI após logout
    function resetUIForLogout() {
      document.getElementById("flashcard-content").textContent = "Por favor, faça login para acessar os flashcards.";
      cardCounter.textContent = "0/0";
      document.getElementById('end-screen').style.display = 'none';
      document.getElementById('flashcard-content').style.display = 'block';
      cardContainer.style.backgroundColor = "white";
      document.getElementById("flashcard-content").style.color = "black";
      document.getElementById('reviewErrorsButton').style.display = 'none';
      document.getElementById('reviewErrorsButton').style.color = 'white';
      document.getElementById('reviewErrorsButton').style.textShadow = 'none';
      document.getElementById('loginEmail').value = '';
      document.getElementById('loginPassword').value = '';
      document.getElementById('loginError').style.display = 'none';
      
      if (isAutoAdvanceActive) {
        stopAutoAdvance();
      }
      
      document.getElementById('statsModal').style.display = 'none';
      document.getElementById('helpModal').style.display = 'none';
      document.getElementById('sessionExpiredModal').style.display = 'none';
      document.getElementById('autoAdvanceSetup').style.display = 'none';
      document.getElementById('autoAdvanceOverlay').style.display = 'none';
      document.getElementById('correctButton').classList.remove('correct');
      document.getElementById('incorrectButton').classList.remove('incorrect');
      document.getElementById('loginModal').style.display = 'flex';
      const mobileBtn = document.getElementById('mobileAnswerBtn');
      if(mobileBtn) mobileBtn.style.display = 'none';
      initialCards = [];
      cards = [];
      currentCard = 0;
      showingFront = true;
      isFinished = false;
      isShuffleActive = false;
      isReviewErrorsMode = false;
      cardAccuracy = {};
      cardResponseTimes = {};
      currentCategory = "Todas";
      
      // --- CORREÇÃO: Esconde o Modal de Filtro e reseta o ícone ---
      const modalFilter = document.getElementById("filterModal");
      if (modalFilter) modalFilter.style.display = "none";
      
      const filterBtn = document.getElementById('filterBtn');
      if(filterBtn) {
          filterBtn.style.color = 'white';
          filterBtn.style.textShadow = 'none';
      }
    }

    // --- FUNÇÕES DE AUTENTICAÇÃO ---
    function showLoginError(message) {
      const errorElement = document.getElementById('loginError');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
    }

    function hideLoginModal() {
      document.getElementById('loginModal').style.display = 'none';
      isAuthenticated = true;
      document.getElementById("flashcard-content").textContent = "Carregando flashcards...";
	  checkAndIncrementStreak();
    }

    function showLoadingIndicator(message = "Carregando...") {
      const indicator = document.getElementById('loadingIndicator');
      const text = indicator.querySelector('.loading-text');
      text.textContent = message;
      indicator.style.display = 'block';
    }

    function hideLoadingIndicator() {
      document.getElementById('loadingIndicator').style.display = 'none';
    }

    function setLoginButtonLoading(isLoading) {
      const button = document.getElementById('loginSubmitBtn');
      const spinner = document.getElementById('loginSpinner');
      const text = document.getElementById('loginBtnText');
      if (isLoading) {
        button.disabled = true;
        text.style.visibility = 'hidden';
        spinner.style.display = 'block';
      } else {
        button.disabled = false;
        text.style.visibility = 'visible';
        spinner.style.display = 'none';
      }
    }

    function saveLoginTime() {
      localStorage.setItem('loginTime', Date.now().toString());
    }

    function isSessionExpired() {
      const loginTime = localStorage.getItem('loginTime');
      if (!loginTime) return true;
      
      const currentTime = Date.now();
      const elapsedTime = currentTime - parseInt(loginTime);
      
      return elapsedTime > SESSION_DURATION;
    }

    function startSessionTimer() {
      if (sessionTimer) {
        clearInterval(sessionTimer);
      }
      
      sessionTimer = setInterval(() => {
        if (isSessionExpired()) {
          clearInterval(sessionTimer);
          expireSession();
        }
      }, 60000);
    }

    function expireSession() {
      if (isAutoAdvanceActive) {
        stopAutoAdvance();
      }
      
      localStorage.removeItem('isAuthenticated');
      localStorage.removeItem('userEmail');
	  localStorage.removeItem('sessionToken');
      localStorage.removeItem('loginTime');
      
      isAuthenticated = false;
      userEmail = '';
      
      document.getElementById('sessionExpiredModal').style.display = 'flex';
      document.getElementById("flashcard-content").textContent = "Sessão expirada. Por favor, faça login novamente.";
      cardCounter.textContent = "0/0";
    }

    function logout() {
      // SALVAR ANTES DE SAIR
      savePositionToBackend();

      if (sessionTimer) {
        clearInterval(sessionTimer);
        sessionTimer = null;
      }
      
      localStorage.removeItem('isAuthenticated');
      localStorage.removeItem('userEmail');
	  localStorage.removeItem('sessionToken');
      localStorage.removeItem('loginTime');
      localStorage.removeItem('flashcardState');
      localStorage.removeItem(`flashcardStats_${SHEET_ID}_${GID}`);
      
      isAuthenticated = false;
      userEmail = '';
      
      resetUIForLogout();
    }

    async function login(event) {
  if (event) event.preventDefault();
  const email = document.getElementById('loginEmail').value.trim();
  const password = document.getElementById('loginPassword').value;
  if (!email || !password) {
    showLoginError('Por favor, preencha todos os campos.');
    return;
  }
  setLoginButtonLoading(true);
  document.getElementById('loginError').style.display = 'none';
  try {
    const formData = new URLSearchParams();
    formData.append('email', email);
    formData.append('password', password);
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    const response = await fetch(WEB_APP_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: formData,
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }
    const result = await response.json();
    if (result.success) {
      userEmail = email;
     userAllowedCourses = result.allowedCourses || []; // Armazena a lista de cursos permitidos vinda do App Script

      // Verifica se o usuário tem permissão para acessar ESTA planilha específica
     // (Verificação local removida para segurança - A validação será feita pelo Servidor ao carregar os cards) 

     // Se passou pela verificação, prossegue com o login normal
      localStorage.setItem('isAuthenticated', 'true');
      localStorage.setItem('userEmail', userEmail);
      localStorage.setItem('sessionToken', result.sessionToken); // <--- NOVA LINHA DE SEGURANÇA
      localStorage.setItem('userAllowedCourses', JSON.stringify(userAllowedCourses)); // Salva no localStorage para persistência
      saveLoginTime();
      startSessionTimer();
      hideLoginModal();
      showLoadingIndicator();
      cardContainer.style.animation = 'none';
      void cardContainer.offsetWidth;
      cardContainer.style.animation = 'pulseSuccess 2s';
      
      // Carrega dados do SRS em paralelo
      loadAllDataFromBackend(userEmail); 

      await loadFlashcardsFromGoogleSheet(SHEET_ID, GID);
      hideLoadingIndicator();
      
      // Tenta recuperar a posição após carregar tudo
      checkForSavedPosition();

    } else {
      showLoginError(result.error || 'Erro durante a autenticação.');
      setLoginButtonLoading(false);
    }
  } catch (error) {
    console.error('Erro no login:', error);
    if (error.name === 'AbortError') {
      showLoginError('Tempo limite excedido. Verifique sua conexão e tente novamente.');
    } else {
      showLoginError('Erro ao conectar com o servidor. Tente novamente.');
    }
    setLoginButtonLoading(false);
  }
}

    function checkAuthentication() {
  const savedAuth = localStorage.getItem('isAuthenticated');
  const savedEmail = localStorage.getItem('userEmail');
  if (savedAuth === 'true' && savedEmail) {
      if (isSessionExpired()) {
        expireSession();
        return;
      }
      isAuthenticated = true;
      userEmail = savedEmail;

    // Carrega cursos permitidos
      const savedAllowedCourses = localStorage.getItem('userAllowedCourses');
      userAllowedCourses = savedAllowedCourses ? JSON.parse(savedAllowedCourses) : [];

      // (Verificação local removida - O Servidor bloqueará o download dos cards se a permissão for inválida)

      document.getElementById('loginModal').style.display = 'none';
      document.getElementById("flashcard-content").textContent = "Carregando flashcards...";
      startSessionTimer();
      showLoadingIndicator();

      // --- ORDEM DE CARREGAMENTO CORRIGIDA ---
      // 1. Baixa seu progresso (Armazém + SRS)
      loadAllDataFromBackend(userEmail).then(() => {
          // 2. Baixa os Cards
          return loadFlashcardsFromGoogleSheet(SHEET_ID, GID);
      }).then(() => {
          // 3. Tudo pronto: Esconde loading e Pergunta se quer continuar
          hideLoadingIndicator();
          checkForSavedPosition();
		  checkAndIncrementStreak();
      });
  } else {
    document.getElementById('loginModal').style.display = 'flex';
  }
}

    // --- FUNÇÕES PRINCIPAIS ---
    function getQueryParam(name) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(name);
    }

    const SHEET_ID = getQueryParam('sheetId');
    const GID = getQueryParam('gid') || '0';

   function saveFlashcardState() {
  if (!requireAuth()) return;
  
  const state = {
    currentCard,
    showingFront,
    fontSize,
    isShuffleActive,
    deckId: `${SHEET_ID}_${GID}`,
    currentCategory,
    cardAccuracy,
    isReviewErrorsMode,       // ← Vírgula adicionada aqui
    currentCardColor,         // ← Agora OK
    currentTextColor          // ← OK (não precisa de vírgula na última linha, mas pode ter)
  };
  
  localStorage.setItem('flashcardState', JSON.stringify(state));
  cardCounter.classList.add('saved');
  setTimeout(() => cardCounter.classList.remove('saved'), 1000);
}

    function loadFlashcardState() {
      const savedState = localStorage.getItem('flashcardState');
      if (!savedState) return false;
      
      try {
        const state = JSON.parse(savedState);
        if (state.deckId === `${SHEET_ID}_${GID}`) {
          currentCard = state.currentCard >= cards.length ? 0 : state.currentCard;
          showingFront = state.showingFront;
          fontSize = state.fontSize;
          currentCategory = state.currentCategory || "Todas";
          
          if (state.cardAccuracy) cardAccuracy = state.cardAccuracy;
          if (state.isReviewErrorsMode !== undefined) {
            isReviewErrorsMode = state.isReviewErrorsMode;
            document.getElementById('reviewErrorsButton').style.display = isReviewErrorsMode ? 'inline-block' : 'none';
            if (isReviewErrorsMode) {
              document.getElementById('reviewErrorsButton').style.color = '#ff5555';
              document.getElementById('reviewErrorsButton').style.textShadow = '0 0 10px rgba(255, 85, 85, 0.7)';
            }
          }
          
          if (state.isShuffleActive !== isShuffleActive) {
            isShuffleActive = state.isShuffleActive;
            if (isShuffleActive) {
              cards = [...cards].sort(() => Math.random() - 0.5);
            } else {
              cards = [...initialCards];
            }
          }
		if (state.currentCardColor !== undefined) {
        currentCardColor = state.currentCardColor;
        cardContainer.style.backgroundColor = currentCardColor;
        document.getElementById("cardColor").value = currentCardColor;
      }
      if (state.currentTextColor !== undefined) {
        currentTextColor = state.currentTextColor;
        document.getElementById("flashcard-content").style.color = currentTextColor;
        document.getElementById("textColor").value = currentTextColor;
      }
          return true;
        }
      } catch (e) {
        console.error("Erro ao carregar estado:", e);
      }
      return false;
    }

    async function loadFlashcardsFromGoogleSheet(sheetId, gid) {
      // 1. TENTATIVA DE CARREGAMENTO LOCAL (CACHE)
      const cacheKey = `cachedCards_${sheetId}_${gid}`;
      const localData = localStorage.getItem(cacheKey);
      let hasLoadedLocal = false;

      if (localData) {
          try {
              console.log("Carregando do Cache Local...");
              const parsedData = JSON.parse(localData);
              if (parsedData && parsedData.length > 0) {
                  processLoadedCards(parsedData, true); // true = origem cache
                  hasLoadedLocal = true;
                  showFeedback("Modo Offline: Cards carregados do cache.", "#4CAF50");
              }
          } catch (e) {
              console.error("Cache inválido", e);
          }
      }

      if (!isAuthenticated && !hasLoadedLocal) {
        document.getElementById("flashcard-content").textContent = "Por favor, faça login para acessar os flashcards.";
        cardCounter.textContent = "0/0";
        return;
      }
      
      if (isSessionExpired()) {
        expireSession();
        return;
      }

      // Se não carregou local, mostra loading para o usuário saber que estamos buscando
      if (!hasLoadedLocal) {
          showLoadingIndicator("Baixando dados de forma segura...");
      }

      // 2. TENTATIVA DE CARREGAMENTO SEGURO (VIA BACKEND)
      // Recupera o token salvo no login
      const sessionToken = localStorage.getItem('sessionToken');
      const userEmail = localStorage.getItem('userEmail');

      if (!sessionToken) {
         if (!hasLoadedLocal) {
            showLoginError("Sessão inválida. Faça login novamente.");
            expireSession();
         }
         return;
      }

      try {
        const formData = new URLSearchParams();
        formData.append('action', 'loadCards');       // Ação nova que criamos no script
        formData.append('email', userEmail);
        formData.append('sessionToken', sessionToken); // Senha da sessão
        formData.append('sheetId', sheetId);
        formData.append('gid', gid);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout
        
        // Chama o Apps Script (mesma URL do login)
        const response = await fetch(WEB_APP_URL, { 
            method: 'POST',
            body: formData,
            signal: controller.signal 
        });
        clearTimeout(timeoutId);
        
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        
        const jsonResponse = await response.json();

        if (!jsonResponse.success) {
            throw new Error(jsonResponse.error || "Erro desconhecido ao baixar cards.");
        }

        // Processa os dados recebidos (Array de Arrays)
        // Ignora a primeira linha (cabeçalho) com .slice(1)
        const rawData = jsonResponse.data.slice(1); 
        let loadedCards = [];

        rawData.forEach(row => {
            // Mapeamento direto das colunas (Ordem da planilha)
            // 0: Frente, 1: Verso, 2: Foco, 3: Disciplina, 4: Tópico, 5: Peso, 6: Tipo, 7: Ano
            const frontText = (row[0] || '').toString().trim();
            const backText = (row[1] || '').toString().trim();
            const foco = (row[2] || "").toString().trim(); 
            let disciplina = (row[3] || "").toString().trim();
            if (disciplina === "") disciplina = "Geral";
            const topico = (row[4] || "").toString().trim();
            const peso = parseInt(row[5]) || 1;
            let tipoRaw = (row[6] || "").toString().trim().toLowerCase();
            const tipo = tipoRaw === "" ? 'simulado' : tipoRaw;
            const ano = (row[7] || "").toString().trim();

            if (frontText && backText) {
                loadedCards.push({ front: frontText, back: backText, tipo, categoria: topico, topico, foco, disciplina, peso, ano });
            }
        });

        if (loadedCards.length > 0) {
            // SUCESSO: Atualiza o Cache e a tela
            localStorage.setItem(cacheKey, JSON.stringify(loadedCards));
            processLoadedCards(loadedCards, false);
            
            if (hasLoadedLocal) {
                showFeedback("Lista de cards atualizada com segurança!", "gold");
            }
        } else if (!hasLoadedLocal) {
            document.getElementById("flashcard-content").textContent = "Nenhum flashcard encontrado na planilha.";
            cardCounter.textContent = "0/0";
        }
        return loadedCards;

      } catch (error) {
          console.error("Erro ao baixar cards:", error);
          if (!hasLoadedLocal) {
              document.getElementById("flashcard-content").textContent = `Erro: ${error.message}`;
              cardCounter.textContent = "0/0";
              // Se o erro for de sessão, força logout
              if (error.message.includes("Sessão") || error.message.includes("acesso")) {
                  setTimeout(expireSession, 3000);
              }
          } else {
              showFeedback("Sem conexão. Usando versão offline.", "#ffa500");
          }
          return [];
      } finally {
          hideLoadingIndicator();
      }
    }

    // Função auxiliar para carregar cards na memória e preparar a tela
    function processLoadedCards(cardsData, isFromCache) {
        initialCards = cardsData;
        // Se estamos iniciando agora (cards vazio) ou carregando do cache, atualiza tudo
        // Se for atualização de rede em segundo plano, atualiza initialCards mas mantém o estudo atual se o usuário já começou
        if (cards.length === 0 || isFromCache) {
            cards = [...initialCards];
            
            const hasSavedState = loadFlashcardState();
            if (!hasSavedState) {
              currentCard = 0;
              showingFront = true;
              cardAccuracy = {};
              isReviewErrorsMode = false;
              currentCategory = "Todas"; // Garante reset limpo
            }
            
            loadStatsFromStorage();
            
            // Destaque visual no botão de configuração
            const btn = document.getElementById("settingsBtn");
            if (btn) {
                btn.classList.add("settings-highlight");
                setTimeout(() => btn.classList.remove("settings-highlight"), 10000);
            }
            updateCard();
        }
    }

    function filterByCategory(category, skipSave = false) {
      if (!requireAuth()) return;
      
      currentCategory = category;
      document.getElementById("mainFilterSelect").value = ""; // Reseta para a palavra "Seleção"
document.getElementById("topicSelect").style.display = "none";
document.getElementById("focoSelect").style.display = "none";
	  categorySelect.title = category; // ← mostra o nome completo em tooltip
      
      if (category === "Todas") {
        cards = [...initialCards];
      } else {
        cards = initialCards.filter(card => card.category === category);
      }
      
      if (isReviewErrorsMode) {
        cards = cards.filter((card, index) => {
          const originalIndex = initialCards.indexOf(card);
          return cardAccuracy[originalIndex] && cardAccuracy[originalIndex].incorrect > 0;
        });
      }
      
      if (isShuffleActive) {
        cards = [...cards].sort(() => Math.random() - 0.5);
      }
      
      if (!skipSave) {
        currentCard = 0;
        showingFront = true;
      }
      
      updateCard();
      if (!skipSave) {
        saveFlashcardState();
      }
    }

    function updateCard() {
	if (typeof handsFreeTimer !== 'undefined') clearTimeout(handsFreeTimer);
	stopSpeech(); // <--- ADICIONE ESTA LINHA
      if (!requireAuth() || cards.length === 0 || isFinished) return;
      const card = cards[currentCard];
      const contentElement = document.getElementById("flashcard-content");
      // --- LÓGICA DE CLOZE (OMISSÃO) ---
      let textToShow = showingFront ? card.front : card.back;
      
      // Segurança básica contra injeção de HTML (Sanitize)
      textToShow = textToShow.replace(/</g, "&lt;").replace(/>/g, "&gt;");

      if (showingFront) {
          // Na FRENTE: Substitui {{texto}} por uma caixa [...]
          // Regex explica: Pega tudo entre {{ e }}
          textToShow = textToShow.replace(/{{(.*?)}}/g, "<span style='background:#333; color:gold; padding:2px 6px; border-radius:4px; border:1px solid #555; cursor:help;' title='Tente lembrar...'>[...]</span>");
      } else {
          // No VERSO: Mostra o texto, destacando a resposta em verde
          // Remove as chaves e pinta o recheio
          textToShow = textToShow.replace(/{{(.*?)}}/g, "<span style='color:#00ff00; font-weight:bold; border-bottom:1px solid #00ff00;'>$1</span>");
      }
      
      contentElement.innerHTML = textToShow;
      // ---------------------------------
      // --- ALTERAÇÃO: Contador Relativo (Mostra posição no filtro atual) ---
      // Ex: Mostra "1 / 15" (sendo 15 o total do tópico filtrado)
      const currentPosition = currentCard + 1;
      const totalInFilter = cards.length;
      cardCounter.innerHTML = `<span class="current-card">${currentPosition}</span>/<span>${totalInFilter}</span>`;
      // ATUALIZA A BARRA DE PROGRESSO
      const progressPercentage = totalInFilter > 0 ? (currentPosition / totalInFilter) * 100 : 0;
      const progressBar = document.getElementById("progressBarFill");
      if(progressBar) {
          progressBar.style.width = `${progressPercentage}%`;
      }
	  contentElement.style.fontSize = fontSize + "pt";
      updateAccuracyButtons();
      if (showingFront) {
        startResponseTimeMeasurement();
      }
      if (isAutoAdvanceActive) {
        autoAdvanceSeconds = autoAdvanceDelay;
        updateAutoAdvanceDisplay();
      }
      if (isHighlightModeActive) {
        applyAsteriskHighlight();
      }
// >>> ADICIONE ESTE BLOCO NO FINAL DA FUNÇÃO updateCard <<<
      if (typeof isAutoTTS !== 'undefined' && isAutoTTS) {
          // Pequeno delay para dar tempo do cérebro processar a troca visual
          setTimeout(() => {
              speakCard();
          }, 500);
      }
      // >>> FIM DO BLOCO <<<
      // --- ATUALIZAÇÃO DOS BOTÕES (SRS vs Normal) ---
      // --- ATUALIZAÇÃO DOS BOTÕES (Controlado pelo Menu Hambúrguer) ---
      // Sincroniza o estado inicial se necessário, garantindo que não fique vazio
      if (typeof currentEvalState === 'undefined') {
          currentEvalState = (typeof isSRSMode !== 'undefined' && isSRSMode) ? 'srs' : 'normal';
      }
      
      // Chama a função que criamos no Passo 3 para decidir o que mostrar
      updateEvalButtonsUI();
// --- CONTROLE DE INTERFACE MOBILE (NOVO) ---
      const isMobile = window.innerWidth <= 768;
      const mobileBtn = document.getElementById('mobileAnswerBtn');
      const srsDiv = document.getElementById('srsButtons');

      if (isMobile) {
          if (showingFront) {
              // ESTADO 1: PERGUNTA (FRENTE)
              // Mostra botão grande "Mostrar Resposta"
              if(mobileBtn) mobileBtn.style.display = 'block';
              // Esconde botões SRS
              if(srsDiv) srsDiv.style.display = 'none';
          } else {
              // ESTADO 2: RESPOSTA (VERSO)
              // Esconde botão grande
              if(mobileBtn) mobileBtn.style.display = 'none';
              // Mostra botões SRS (Se estiver no modo SRS ou Normal)
              // Nota: Forçamos o display flex para garantir que apareça no mobile
              if(srsDiv) srsDiv.style.display = 'flex';
          }
      } else {
          // No PC, esconde o botão mobile para não atrapalhar
          if(mobileBtn) mobileBtn.style.display = 'none';
      }
      // Ajuste extra para o botão de embaralhar (Opcional: esconde no SRS visualmente)
      // Nota: A lógica principal de esconder botões já está dentro do updateEvalButtonsUI
      if (typeof isSRSMode !== 'undefined' && isSRSMode) {
          const shuffleBtn = document.getElementById('shuffleButton');
          if (shuffleBtn) shuffleBtn.style.display = 'none';
      } else {
          const shuffleBtn = document.getElementById('shuffleButton');
          if (shuffleBtn) shuffleBtn.style.display = 'inline-block';
      }
    }

    function updateAccuracyButtons() {
      const correctButton = document.getElementById('correctButton');
      const incorrectButton = document.getElementById('incorrectButton');
      
      const currentOriginalCard = initialCards.indexOf(cards[currentCard]);
      
      if (currentOriginalCard !== -1 && cardAccuracy[currentOriginalCard]) {
        if (cardAccuracy[currentOriginalCard].correct > 0) {
          correctButton.classList.add('correct');
          incorrectButton.classList.remove('incorrect');
        } else if (cardAccuracy[currentOriginalCard].incorrect > 0) {
          incorrectButton.classList.add('incorrect');
          correctButton.classList.remove('correct');
        } else {
          correctButton.classList.remove('correct');
          incorrectButton.classList.remove('incorrect');
        }
      } else {
        correctButton.classList.remove('correct');
        incorrectButton.classList.remove('incorrect');
      }
    }

    function nextCard() {
      if (!requireAuth() || isFinished) return;
      
      if (currentCard === cards.length - 1) {
        showEndScreen();
        saveFlashcardState();
        return;
      }
      
      currentCard = (currentCard + 1) % cards.length;
      showingFront = true;
      updateCard();
      saveFlashcardState();
    }

    function prevCard() {
      if (!requireAuth() || isFinished) return;
      
      currentCard = (currentCard - 1 + cards.length) % cards.length;
      showingFront = true;
      updateCard();
      saveFlashcardState();
    }

    function flipCard() {
      if (!requireAuth() || isFinished) return;

      const content = document.getElementById("flashcard-content");
      
      // 1. Inicia a animação visual
      content.classList.add("animate-flip");

      // 2. Aguarda metade do tempo (0.2s) para trocar o texto quando o card estiver "de lado" (90 graus)
      setTimeout(() => {
          if (showingFront) {
            endResponseTimeMeasurement();
          }
          showingFront = !showingFront;
          updateCard();
          saveFlashcardState();
      }, 200);

      // 3. Remove a classe ao final da animação (0.4s) para poder usar novamente depois
      setTimeout(() => {
          content.classList.remove("animate-flip");
      }, 400);
    }

    function reviewAndRetreat() {
      if (!requireAuth() || isFinished) return;
      
      if (!showingFront) {
        showingFront = true;
        updateCard();
      } else {
        if (currentCard === 0) {
          currentCard = cards.length - 1;
        } else {
          currentCard--;
        }
        showingFront = false;
        updateCard();
      }
      saveFlashcardState();
    }

    function reviewAndAdvance() {
      if (!requireAuth() || isFinished) return;
      
      // CASO 1: Está na Frente (Pergunta) -> Vira para o Verso (Resposta) COM ANIMAÇÃO NO TEXTO
      if (showingFront) {
        const content = document.getElementById("flashcard-content"); // <--- MUDAMOS O ALVO AQUI
        content.classList.add("animate-flip");

        setTimeout(() => {
            endResponseTimeMeasurement();
            showingFront = false;
            updateCard();
            saveFlashcardState();
        }, 200);

        setTimeout(() => {
            content.classList.remove("animate-flip");
        }, 400);

      } else {
        // CASO 2: Está no Verso -> Vai para o Próximo Card (Sem animação)
        nextCard();
        saveFlashcardState();
      }
    }

    function markAsCorrect() {
	triggerVisualFeedback('success');
      if (!requireAuth() || isFinished) return;
      
      const currentOriginalCard = initialCards.indexOf(cards[currentCard]);
      
      if (currentOriginalCard !== -1) {
        if (!cardAccuracy[currentOriginalCard]) {
          cardAccuracy[currentOriginalCard] = { correct: 0, incorrect: 0 };
        }
        
        cardAccuracy[currentOriginalCard].correct++;
        updateAccuracyButtons();
        nextCard();
        saveFlashcardState();
      }
    }

    function markAsIncorrect() {
	triggerVisualFeedback('error');
      if (!requireAuth() || isFinished) return;
      
      const currentOriginalCard = initialCards.indexOf(cards[currentCard]);
      
      // Verifica Sanguessuga e contabiliza erro
      if (currentOriginalCard !== -1) {
        checkLeech(currentOriginalCard);

        if (!cardAccuracy[currentOriginalCard]) {
          cardAccuracy[currentOriginalCard] = { correct: 0, incorrect: 0 };
        }
        
        cardAccuracy[currentOriginalCard].incorrect++;
        updateAccuracyButtons();
        nextCard();
        saveFlashcardState();
      }
    }
// --- LÓGICA DO MENU DE AVALIAÇÃO (COM MEMÓRIA) ---
    // 1. Ao iniciar, tenta recuperar o que estava salvo. Se não tiver nada, usa 'normal'.
    let currentEvalState = localStorage.getItem('chicoEvalMode') || 'normal';
	
    function openEvalModal() {
        document.getElementById('evalModal').style.display = 'flex';
    }

    function closeEvalModal() {
        document.getElementById('evalModal').style.display = 'none';
    }

    function setEvalMode(mode) {
        currentEvalState = mode;
        
        // --- SALVA A ESCOLHA NO NAVEGADOR ---
        localStorage.setItem('chicoEvalMode', mode);

        // Atualiza a variável global do sistema
        if (mode === 'srs') {
            isSRSMode = true;
        } else if (mode === 'normal') {
            isSRSMode = false;
        }
        
        updateEvalButtonsUI(); // Atualiza a tela
        closeEvalModal();
        showFeedback("Modo salvo!", "gold");
    }

    function updateEvalButtonsUI() {
        const srsDiv = document.getElementById('srsButtons');
        const btnCorrect = document.getElementById('correctButton');
        const btnIncorrect = document.getElementById('incorrectButton');

        // Reseta tudo para invisível primeiro
        if(srsDiv) srsDiv.style.display = 'none';
        if(btnCorrect) btnCorrect.style.display = 'none';
        if(btnIncorrect) btnIncorrect.style.display = 'none';

        if (currentEvalState === 'hidden') {
            return; // Se escolheu limpar, nada aparece.
        }

        if (currentEvalState === 'srs') {
            if(srsDiv) srsDiv.style.display = 'flex';
        } else {
            // Modo Normal (Certo/Errado)
            if(btnCorrect) btnCorrect.style.display = 'inline-block';
            if(btnIncorrect) btnIncorrect.style.display = 'inline-block';
        }
    }
    
    // Força a atualização visual e lógica assim que a página carregar
    document.addEventListener("DOMContentLoaded", () => {
        // Sincroniza a variável interna isSRSMode com a escolha salva para que os ATALHOS funcionem
        if (typeof isSRSMode !== 'undefined') {
            if (currentEvalState === 'srs') {
                isSRSMode = true;
            } else {
                isSRSMode = false;
            }
        }
        
        // Atualiza os botões visualmente
        setTimeout(updateEvalButtonsUI, 500);
    });
    function toggleReviewErrors() {
      if (!requireAuth()) return;
      
      isReviewErrorsMode = !isReviewErrorsMode;
      
      if (isReviewErrorsMode) {
        cards = cards.filter((card, index) => {
          const originalIndex = initialCards.indexOf(card);
          return cardAccuracy[originalIndex] && cardAccuracy[originalIndex].incorrect > 0;
        });
        
        if (cards.length === 0) {
          alert("Não há cards marcados como incorretos para revisão.");
          isReviewErrorsMode = false;
          cards = [...initialCards];
          if (currentCategory !== "Todas") {
            cards = initialCards.filter(card => card.category === currentCategory);
          }
          document.getElementById('reviewErrorsButton').style.display = 'none';
          return;
        }
        
        document.getElementById('reviewErrorsButton').style.color = '#ff5555';
        document.getElementById('reviewErrorsButton').style.textShadow = '0 0 10px rgba(255, 85, 85, 0.7)';
      } else {
        if (currentCategory === "Todas") {
          cards = [...initialCards];
        } else {
          cards = initialCards.filter(card => card.category === currentCategory);
        }
        
        document.getElementById('reviewErrorsButton').style.color = 'white';
        document.getElementById('reviewErrorsButton').style.textShadow = 'none';
      }
      
      if (isShuffleActive) {
        cards = [...cards].sort(() => Math.random() - 0.5);
      }
      
      currentCard = 0;
      showingFront = true;
      updateCard();
      saveFlashcardState();
    }

    function reviewIncorrectCards() {
      isReviewErrorsMode = true;
      document.getElementById('reviewErrorsButton').style.display = 'inline-block';
      document.getElementById('reviewErrorsButton').style.color = '#ff5555';
      document.getElementById('reviewErrorsButton').style.textShadow = '0 0 10px rgba(255, 85, 85, 0.7)';
      
      if (currentCategory === "Todas") {
        cards = [...initialCards];
      } else {
        cards = initialCards.filter(card => card.category === currentCategory);
      }
      
      cards = cards.filter((card, index) => {
        const originalIndex = initialCards.indexOf(card);
        return cardAccuracy[originalIndex] && cardAccuracy[originalIndex].incorrect > 0;
      });
      
      if (cards.length === 0) {
        alert("Não há cards marcados como incorretos para revisão.");
        isReviewErrorsMode = false;
        cards = [...initialCards];
        if (currentCategory !== "Todas") {
          cards = initialCards.filter(card => card.category === currentCategory);
        }
        document.getElementById('reviewErrorsButton').style.display = 'none';
        return;
      }
      
      if (isShuffleActive) {
        cards = [...cards].sort(() => Math.random() - 0.5);
      }
      
      currentCard = 0;
      showingFront = true;
      updateCard();
      saveFlashcardState();
    }

  function toggleShuffleMode() {
  if (!requireAuth() || isFinished) return;
  const shuffleButton = document.getElementById("shuffleButton");
  if (!isShuffleActive) {
    // Embaralhar
    for (let i = cards.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1)); // Correção: uso correto de random
      [cards[i], cards[j]] = [cards[j], cards[i]];
    }
       isShuffleActive = true;
    shuffleButton.style.color = "#00FFFF";
    shuffleButton.style.textShadow = "0 0 8px #00FFFF, 0 0 10px #00FFFF, 0 0 15px rgba(0, 255, 255, 0.8)";
  } else {
    // Restaurar ordem original
    if (currentCategory === "Todas") {
      cards = [...initialCards];
    } else {
      cards = initialCards.filter(card => card.category === currentCategory);
    }
    if (isReviewErrorsMode) {
      cards = cards.filter((card, index) => {
        const originalIndex = initialCards.indexOf(card);
        return cardAccuracy[originalIndex] && cardAccuracy[originalIndex].incorrect > 0;
      });
    }
    isShuffleActive = false;
    shuffleButton.style.color = "white";
    shuffleButton.style.textShadow = "none";
  }
  currentCard = 0;
  showingFront = true;
  updateCard();
  saveFlashcardState();
}

  function adjustFontSize(change) {
      if (!requireAuth()) return;
      
      // 1. Calcula o novo tamanho (Limites: 10pt a 55pt)
      fontSize += change * 1.2;
      fontSize = Math.max(10, Math.min(55, fontSize));
      
      // 2. Aplica ao texto do card
      const content = document.getElementById("flashcard-content");
      if (content) content.style.fontSize = fontSize + "pt";
      
      // 3. Feedback Visual "Infalível" (Criação Dinâmica)
      // Remove aviso anterior se houver (para não empilhar)
      const oldMsg = document.getElementById('temp-font-msg');
      if (oldMsg) oldMsg.remove();

      // Cria o elemento na hora
      const msg = document.createElement('div');
      msg.id = 'temp-font-msg';
      msg.textContent = "Tamanho: " + fontSize.toFixed(1) + "pt";
      
      // Aplica estilo FORÇADO (Ignora CSS externo)
      Object.assign(msg.style, {
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: 'rgba(0, 0, 0, 0.7)', // Fundo Preto
        color: '#FFD700',                       // Texto Dourado
        border: '2px solid #FFD700',            // Borda Dourada
        padding: '5px 10px',
        borderRadius: '12px',
        fontSize: '1.8em',
        fontWeight: 'bold',
        zIndex: '999999',                       // Acima de TUDO
        boxShadow: '0 0 30px rgba(255, 215, 0, 0.6)',
        pointerEvents: 'none',                  // Clica através dele
        textAlign: 'center',
        fontFamily: 'Arial, sans-serif'
      });

      document.body.appendChild(msg);

      // Animação para sumir suavemente
      setTimeout(() => {
        msg.style.transition = 'opacity 0.5s ease';
        msg.style.opacity = '0';
        // Remove do HTML após o efeito
        setTimeout(() => msg.remove(), 500);
      }, 1000); // Fica visível por 1 segundo
      
      saveFlashcardState();
    }

    function toggleCardColorMenu() {
      if (!requireAuth()) return;
      
      const menu = document.getElementById("cardColor");
      menu.style.display = menu.style.display === "none" ? "inline-block" : "none";
    }

    function toggleTextColorMenu() {
      if (!requireAuth()) return;
      
      const menu = document.getElementById("textColor");
      menu.style.display = menu.style.display === "none" ? "inline-block" : "none";
    }

 function changeCardColor(color) {
  if (!requireAuth()) return;
  cardContainer.style.backgroundColor = color;
  currentCardColor = color; // Salva a cor atual
  saveFlashcardState();
}

function changeTextColor(color) {
  if (!requireAuth()) return;
  document.getElementById("flashcard-content").style.color = color;
  currentTextColor = color; // Salva a cor atual
  saveFlashcardState();
}

    function resetTimer() {
      if (!requireAuth()) return;
      
      timerSeconds = 0;
      timerElement.textContent = "00:00";
    }

    function updateTimer() {
      if (!isAuthenticated) return;
      timerSeconds++;
      const minutes = String(Math.floor(timerSeconds / 60)).padStart(2, '0');
      const seconds = String(timerSeconds % 60).padStart(2, '0');
      timerElement.textContent = `${minutes}:${seconds}`;
    }

    function goToSpecificCard() {
      if (!requireAuth() || isFinished) return;
      
      const value = document.getElementById("goToCard").value;
      const number = parseInt(value, 10);
      if (!isNaN(number) && number >= 1 && number <= cards.length) {
        currentCard = number - 1;
        showingFront = true;
        updateCard();
        saveFlashcardState();
      } else {
        alert("Número do card inválido. Insira um número entre 1 and " + cards.length);
      }
      document.getElementById("goToCard").value = '';
    }

    function showTooltipOnHover(el) {
      clearTimeout(el.tooltipTimer);
      el.classList.add("show-tooltip");
      el.tooltipTimer = setTimeout(() => {
        el.classList.remove("show-tooltip");
      }, 1000);
    }

    function hideTooltipOnLeave(el) {
      clearTimeout(el.tooltipTimer);
      el.classList.remove("show-tooltip");
    }

    function toggleHelpModal() {
      helpModal.style.display = helpModal.style.display === "none" ? "flex" : "none";
    }
	function toggleManualModal() {
      const modal = document.getElementById('manualModal');
      modal.style.display = modal.style.display === "none" ? "flex" : "none";
    }

    // Funções para o Temporizador Automático
   function toggleAutoAdvance() {
  if (!requireAuth()) return;
  
  if (!isAutoAdvanceActive) {
    // Iniciar com último tempo usado
    startAutoAdvanceWithDelay(lastAutoAdvanceDelay);
  } else if (isAutoAdvancePaused) {
    // Continuar se estiver pausado
    resumeAutoAdvance();
  } else {
    // Pausar se estiver rodando
    pauseAutoAdvance();
  }
  }

    function startAutoAdvance() {
        if (!requireAuth()) return;
        
        if (isAutoAdvanceActive) return;
        document.getElementById("autoAdvanceDelayInput").value = autoAdvanceDelay;
        document.getElementById("autoAdvanceSetup").style.display = "flex";
        document.getElementById("autoAdvanceOverlay").style.display = "block";
    }

    function confirmAutoAdvanceDelay() {
  if (!requireAuth()) return;
  const userInput = document.getElementById("autoAdvanceDelayInput").value;
  const newDelay = parseInt(userInput, 10);
  document.getElementById("autoAdvanceSetup").style.display = "none";
  document.getElementById("autoAdvanceOverlay").style.display = "none";
  
  if (isNaN(newDelay) || newDelay <= 0) {
    showFeedback("Número inválido!", "#ff5555");
    return;
  }
  
    lastAutoAdvanceDelay = newDelay;
  localStorage.setItem('lastAutoAdvanceDelay', newDelay.toString());
  if (isAutoAdvanceActive) {
    autoAdvanceDelay = newDelay;
    autoAdvanceSeconds = newDelay;
    updateAutoAdvanceDisplay();
    showFeedback(`Tempo alterado para ${newDelay}s`, "gold");
  } else {
    startAutoAdvanceWithDelay(newDelay);
    showFeedback(`Temporizador iniciado (${newDelay}s)`, "gold");
  }
}

    function cancelAutoAdvanceDelay() {
        document.getElementById("autoAdvanceSetup").style.display = "none";
        document.getElementById("autoAdvanceOverlay").style.display = "none";
    }

 function stopAutoAdvance() {
  if (!isAutoAdvanceActive) return;
  clearInterval(autoAdvanceInterval);
  autoAdvanceInterval = null;
  isAutoAdvanceActive = false;
  isAutoAdvancePaused = false;
  autoAdvanceSeconds = 0;
  updateAutoAdvanceDisplay();
  updateAutoAdvanceUI(); // ← ESSENCIAL: restaura o botão ⏳
}

    function updateAutoAdvanceDisplay() {
        if (autoAdvanceTimerDisplay) autoAdvanceTimerDisplay.textContent = `${autoAdvanceSeconds}s`;
    }

    function recordResponseTime(cardIndex, timeSpent) {
      if (!requireAuth()) return;
      
      if (!cardResponseTimes[cardIndex]) {
        cardResponseTimes[cardIndex] = { times: [], avgTime: 0 };
      }
      
      cardResponseTimes[cardIndex].times.push(timeSpent);
      const times = cardResponseTimes[cardIndex].times;
      const sum = times.reduce((a, b) => a + b, 0);
      cardResponseTimes[cardIndex].avgTime = Math.round(sum / times.length);
    }

    function saveStatsToStorage() {
      if (!requireAuth()) return;
      
     const stats = {
        responseTimes: cardResponseTimes,
        lastAccess: new Date().toISOString(),
        cardAccuracy: cardAccuracy,
        userLearningStats: userLearningStats // Salva o aprendizado
      };
      
      localStorage.setItem(`flashcardStats_${SHEET_ID}_${GID}`, JSON.stringify(stats));
    }

    function loadStatsFromStorage() {
      const savedStats = localStorage.getItem(`flashcardStats_${SHEET_ID}_${GID}`);
      if (!savedStats) return;
      
      try {
        const stats = JSON.parse(savedStats);
        cardResponseTimes = stats.responseTimes || {};
        if (stats.lastAccess) lastAccessDate = new Date(stats.lastAccess);
        if (stats.cardAccuracy) cardAccuracy = stats.cardAccuracy;
        
        // Carrega a inteligência adaptativa
        if (stats.userLearningStats) {
            userLearningStats = stats.userLearningStats;
            
            // --- VACINA DE SEGURANÇA ---
            // Se salvou com o nome antigo, converte para o novo ou cria vazio
            if (!userLearningStats.topicWeights) {
                userLearningStats.topicWeights = userLearningStats.disciplineWeights || {};
            }
        }
      } catch (e) {
        console.error("Erro ao carregar estatísticas:", e);
      }
    }

    function startResponseTimeMeasurement() {
      cardViewStartTime = Date.now();
    }

    function endResponseTimeMeasurement() {
      if (cardViewStartTime === 0) return;

      try {
        const rawTime = (Date.now() - cardViewStartTime) / 1000;
        const timeSpent = Math.min(rawTime, 120); 

        // --- VERIFICA SE O MODO FOCO ESTÁ ATIVO NO HTML ---
        // Se o modal não existir (primeiro load) ou estiver marcado, consideramos true
        const focusCheckbox = document.getElementById('enableFocusMode');
        const isFocusEnabled = focusCheckbox ? focusCheckbox.checked : true;

        // Se o foco estiver DESLIGADO, a gente só grava o tempo e sai, sem mudar pesos.
        if (!isFocusEnabled) {
             recordResponseTime(currentCard, Math.round(timeSpent));
             saveStatsToStorage();
             return; // <--- SAI DA FUNÇÃO AQUI
        }
        // --------------------------------------------------

        // --- LÓGICA ADAPTATIVA (Só roda se não saiu acima) ---
        const currentCardObj = cards[currentCard];
        
        if (currentCardObj) {
            const currentTopic = currentCardObj.topico; 
            const charCount = (currentCardObj.front.length + currentCardObj.back.length) || 1;
            const currentSpeed = timeSpent / charCount;

            if (!userLearningStats.topicWeights) userLearningStats.topicWeights = {};

            userLearningStats.totalTimeRead += timeSpent;
            userLearningStats.totalCharsRead += charCount;
            
            const globalAvgSpeed = userLearningStats.totalCharsRead > 0 
                ? userLearningStats.totalTimeRead / userLearningStats.totalCharsRead 
                : 0.5;

            if (currentTopic && userLearningStats.topicWeights[currentTopic] === undefined) {
                userLearningStats.topicWeights[currentTopic] = 0; 
            }

            // DIFICULDADE
            if (timeSpent > 5 && currentSpeed > (globalAvgSpeed * 1.5)) {
                if (currentTopic) {
                    userLearningStats.topicWeights[currentTopic] += 0.5; 
                    showFeedback(`Focando em: ${currentTopic}`, "#ff5555");

                    const candidates = initialCards.filter(c => 
                        c.topico === currentTopic && !cards.includes(c)
                    );
                    if (candidates.length > 0) {
                        const reinforcementCard = candidates[Math.floor(Math.random() * candidates.length)];
                        const insertIndex = Math.min(currentCard + 3, cards.length);
                        cards.splice(insertIndex, 0, reinforcementCard);
                    }
                }
            }
            // RECUPERAÇÃO
            else if (timeSpent > 2 && currentSpeed <= (globalAvgSpeed * 1.2)) {
                if (currentTopic && userLearningStats.topicWeights[currentTopic] > 0) {
                    userLearningStats.topicWeights[currentTopic] -= 0.25;
                    if (userLearningStats.topicWeights[currentTopic] < 0) userLearningStats.topicWeights[currentTopic] = 0;
                }
            }
        }
        
        recordResponseTime(currentCard, Math.round(timeSpent));
        saveStatsToStorage();

      } catch (error) {
        console.error("Erro na inteligência adaptativa:", error);
      } finally {
        cardViewStartTime = 0;
      }
    }

    function changeStatsTab(tabName) {
      document.querySelectorAll('.stats-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      document.querySelectorAll('.stats-content').forEach(content => {
        content.classList.remove('active');
      });
      
      document.querySelector(`.stats-tab:nth-child(${tabName === 'time' ? 1 : 2})`).classList.add('active');
      document.getElementById(`${tabName}Stats`).classList.add('active');
      
      if (tabName === 'accuracy') {
        updateAccuracyStats();
      }
    }

    function updateAccuracyStats() {
      if (!requireAuth()) return;
      
      let totalCorrect = 0;
      let totalIncorrect = 0;
      let totalCards = initialCards.length;
      
      Object.values(cardAccuracy).forEach(accuracy => {
        totalCorrect += accuracy.correct || 0;
        totalIncorrect += accuracy.incorrect || 0;
      });
      
      const totalAttempts = totalCorrect + totalIncorrect;
      const accuracyRate = totalAttempts > 0 ? Math.round((totalCorrect / totalAttempts) * 100) : 0;
      
      document.getElementById('totalCardsCount').textContent = totalCards;
      document.getElementById('correctCount').textContent = totalCorrect;
      document.getElementById('incorrectCount').textContent = totalIncorrect;
      document.getElementById('accuracyRate').textContent = `${accuracyRate}%`;
      
      const correctPercentage = totalAttempts > 0 ? (totalCorrect / totalAttempts) * 100 : 0;
      const incorrectPercentage = totalAttempts > 0 ? (totalIncorrect / totalAttempts) * 100 : 0;
      
      document.getElementById('correctMeter').style.width = `${correctPercentage}%`;
      document.getElementById('correctMeter').textContent = `${Math.round(correctPercentage)}%`;
      document.getElementById('incorrectMeter').style.width = `${incorrectPercentage}%`;
      document.getElementById('incorrectMeter').textContent = `${Math.round(incorrectPercentage)}%`;
      
      const incorrectCardsList = document.getElementById('incorrectCardsList');
      incorrectCardsList.innerHTML = '';
      
      let hasIncorrectCards = false;
      
      initialCards.forEach((card, index) => {
        if (cardAccuracy[index] && cardAccuracy[index].incorrect > 0) {
          hasIncorrectCards = true;
          const item = document.createElement('div');
          item.className = 'card-review-item';
          item.innerHTML = `
            <div class="card-review-content">
              <strong>Card #${index + 1}:</strong> ${card.front.substring(0, 50)}${card.front.length > 50 ? '...' : ''}
            </div>
            <div class="card-review-time">${cardAccuracy[index].incorrect} ❌</div>
          `;
          incorrectCardsList.appendChild(item);
        }
      });
      
      if (!hasIncorrectCards) {
        incorrectCardsList.innerHTML = '<p>Nenhum card marcado como incorreto.</p>';
      }
    }

    function updateStatsModal() {
      if (!requireAuth()) return;
      
      const lastAccessElement = document.getElementById("lastAccessDate");
      if (lastAccessDate) {
        lastAccessElement.textContent = lastAccessDate.toLocaleString();
      } else {
        lastAccessElement.textContent = "Nenhum registro encontrado.";
      }
      
      const performanceElement = document.getElementById("performanceSummary");
      const cardEntries = Object.entries(cardResponseTimes);
      
      if (cardEntries.length === 0) {
        performanceElement.innerHTML = '<p>Nenhum dado de desempenho disponível.</p>';
      } else {
        let totalTime = 0;
        let totalCards = 0;
        cardEntries.forEach(([cardIndex, data]) => {
          totalTime += data.avgTime * data.times.length;
          totalCards += data.times.length;
        });
        
        const avgTime = totalCards > 0 ? Math.round(totalTime / totalCards) : 0;
        performanceElement.innerHTML = `
          <p>Total de cards revisados: <strong>${cardEntries.length}</strong></p>
          <p>Tempo médio por card: <strong>${avgTime}s</strong></p>
        `;
      }
      
      const reviewCardsListElement = document.getElementById("reviewCardsList");
      reviewCardsListElement.innerHTML = '';
      
      if (cardEntries.length === 0) {
        reviewCardsListElement.innerHTML = '<p>Nenhum dado de tempo de resposta disponível.</p>';
        return;
      }
      
      cardEntries.sort((a, b) => b[1].avgTime - a[1].avgTime);
      cardEntries.forEach(([cardIndex, data]) => {
        const card = initialCards[cardIndex];
        if (card) {
          const item = document.createElement('div');
          item.className = 'card-review-item';
          item.innerHTML = `
            <div class="card-review-content">
              <strong>Card #${parseInt(cardIndex) + 1}:</strong> ${card.front.substring(0, 50)}${card.front.length > 50 ? '...' : ''}
            </div>
            <div class="card-review-time">${data.avgTime}s</div>
          `;
          reviewCardsListElement.appendChild(item);
        }
      });
    }

    function toggleStatsModal() {
      if (!requireAuth()) return;
      
      const modal = document.getElementById("statsModal");
      if (modal.style.display === "none") {
        modal.style.display = "flex";
        updateStatsModal();
        updateAccuracyStats();
      } else {
        modal.style.display = "none";
      }
    }

    function showEndScreen() {
      if (!requireAuth()) return;
      
      document.getElementById('flashcard-content').style.display = 'none';
      document.getElementById('end-screen').style.display = 'flex';
      isFinished = true;

      // --- INÍCIO DA ANIMAÇÃO DE CONFETES ---
      try {
        var duration = 3 * 1000; // Duração: 3 segundos
        var end = Date.now() + duration;

        (function frame() {
          // Lança confetes da esquerda
          confetti({
            particleCount: 5,
            angle: 60,
            spread: 55,
            origin: { x: 0 },
            colors: ['#FFD700', '#FFFFFF', '#DAA520'], // Dourado, Branco e Ouro Velho
            zIndex: 10001 // Garante que apareça acima de tudo
          });
          // Lança confetes da direita
          confetti({
            particleCount: 5,
            angle: 120,
            spread: 55,
            origin: { x: 1 },
            colors: ['#FFD700', '#FFFFFF', '#DAA520'],
            zIndex: 10001
          });

          if (Date.now() < end) {
            requestAnimationFrame(frame);
          }
        }());
      } catch (e) {
        console.log("Biblioteca de confetes não carregada");
      }
      // --- FIM DOS CONFETES ---
      
      let totalCorrect = 0;
      let totalIncorrect = 0;
      
      Object.values(cardAccuracy).forEach(accuracy => {
        totalCorrect += accuracy.correct || 0;
        totalIncorrect += accuracy.incorrect || 0;
      });
      
      const totalAttempts = totalCorrect + totalIncorrect;
      const accuracyRate = totalAttempts > 0 ? Math.round((totalCorrect / totalAttempts) * 100) : 0;
      
      document.getElementById('accuracy-results').innerHTML = `
        <p>Acertos: ${totalCorrect} | Erros: ${totalIncorrect}</p>
        <p>Taxa de acerto: ${accuracyRate}%</p>
      `;
      
      if (totalIncorrect > 0) {
        document.getElementById('review-errors-button').style.display = 'block';
      } else {
        document.getElementById('review-errors-button').style.display = 'none';
      }
    }

    function restartFlashcards() {
      if (!requireAuth()) return;
      
      document.getElementById('end-screen').style.display = 'none';
      document.getElementById('flashcard-content').style.display = 'block';
      currentCard = 0;
      showingFront = true;
      isFinished = false;
      updateCard();
      saveFlashcardState();
    }

    function reviewErrorsFromEndScreen() {
      document.getElementById('end-screen').style.display = 'none';
      document.getElementById('flashcard-content').style.display = 'block';
      isFinished = false;
      reviewIncorrectCards();
    }

// --- IMPLEMENTAÇÃO DE GESTOS (SWIPE) ---
    const touchArea = document.getElementById('card-container');
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;

    if (touchArea) {
        touchArea.addEventListener('touchstart', function(e) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: true});

        touchArea.addEventListener('touchend', function(e) {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleGesture();
        }, {passive: true});
    }

    function handleGesture() {
        const xDiff = touchEndX - touchStartX;
        const yDiff = touchEndY - touchStartY;
        
        // Ignora se for scroll vertical
        if (Math.abs(yDiff) > Math.abs(xDiff)) return;

        // Sensibilidade mínima de 50px
        if (Math.abs(xDiff) < 50) {
            // Se o movimento for muito curto, consideramos um "Toque" simples
            if (Math.abs(xDiff) < 10 && Math.abs(yDiff) < 10) {
                flipCard(); 
            }
            return;
        }

        if (xDiff > 0) {
		triggerVisualFeedback('success');
            // SWIPE DIREITA (→) = Acertei / Avançar
            showSwipeFeedback('right');
            if (!showingFront) {
                 if (typeof isSRSMode !== 'undefined' && isSRSMode) rateCardSRS('good', null, '#90ee90');
                 else markAsCorrect();
            } else {
                 flipCard();
            }
        } else {
		triggerVisualFeedback('error');
            // SWIPE ESQUERDA (←) = Errei / Repetir
            showSwipeFeedback('left');
            if (!showingFront) {
                 if (typeof isSRSMode !== 'undefined' && isSRSMode) rateCardSRS('again', null, '#ff5555');
                 else markAsIncorrect();
            } else {
                 flipCard();
            }
        }
    }
// --- FUNÇÃO DE FEEDBACK VISUAL (BORDAS) ---
    function triggerVisualFeedback(type) {
        const container = document.body; // Aplica na tela toda
        // Remove classes antigas para permitir reiniciar a animação
        container.classList.remove('flash-success-anim', 'flash-error-anim');
        
        // Força um reflow (truque para reiniciar animação CSS)
        void container.offsetWidth;
        
        if (type === 'success') {
            container.classList.add('flash-success-anim');
        } else {
            container.classList.add('flash-error-anim');
        }
        
        // Limpa a classe após terminar
        setTimeout(() => {
            container.classList.remove('flash-success-anim', 'flash-error-anim');
        }, 400);
    }
    // Feedback Visual do Swipe
    function showSwipeFeedback(direction) {
        const feedback = document.createElement('div');
        feedback.innerHTML = direction === 'right' ? '✅' : '❌';
        feedback.style.position = 'absolute';
        feedback.style.top = '50%';
        feedback.style.left = direction === 'right' ? '70%' : '30%';
        feedback.style.transform = 'translate(-50%, -50%)';
        feedback.style.fontSize = '5em';
        feedback.style.opacity = '0.8';
        feedback.style.zIndex = '1000';
        feedback.style.pointerEvents = 'none';
        feedback.style.transition = 'opacity 0.5s';
        
        const container = document.getElementById('card-container');
        if(container) container.appendChild(feedback);
        
        setTimeout(() => {
            feedback.style.opacity = '0';
            setTimeout(() => feedback.remove(), 500);
        }, 200);
    }
	// --- FUNÇÃO ANTI-SANGUESSUGA (LEECH) ---
    function checkLeech(cardIndex) {
        // Segurança: verifica se o card existe
        if (!initialCards || !initialCards[cardIndex]) return;

        const cardId = generateCardId(initialCards[cardIndex].front);
        
        // Garante que o objeto de progresso existe
        if (!userSRSProgress[cardId]) userSRSProgress[cardId] = {};
        if (!userSRSProgress[cardId].lapses) userSRSProgress[cardId].lapses = 0;
        
        // Incrementa o contador de erros (lapses)
        userSRSProgress[cardId].lapses++;
        
        // LIMITE DE 5 ERROS
        if (userSRSProgress[cardId].lapses >= 5) {
            // 1. Alerta na tela (Modal)
            showCustomAlert(`⚠️ CUIDADO: SANGUESSUGA! ⚠️\n\nVocê já errou este card ${userSRSProgress[cardId].lapses} vezes.\n\nSugestão: Não tente decorar à força. Volte na teoria e entenda o conceito.`);
            
            // 2. Marca visual no card atual (Borda vermelha e aviso)
            const content = document.getElementById("flashcard-content");
            if (content) {
                content.style.border = "3px solid #ff5555";
                content.innerHTML += "<br><br><span style='color:#ff5555; font-size:0.9em; font-weight:bold; background:rgba(0,0,0,0.8); padding:5px; border-radius:5px;'>⚠️ [REVISAR TEORIA]</span>";
            }
        }
    }
	// --- TEXT-TO-SPEECH (PIPER NEURAL - WEBASSEMBLY) ---
    // Carrega uma IA de voz neural direto no navegador (Qualidade Estúdio)
    let isAutoTTS = false; 
    let piperWorker = null;
    let isPiperLoading = false;
    let audioContext = null;

    // Configuração da Voz (Modelo pt_BR-faber-medium - Voz Masculina Neural)
    // Se quiser feminina, mude para 'pt_BR_lara-medium' nas URLs abaixo
    const PIPER_MODEL_URL = "https://huggingface.co/rhasspy/piper-voices/resolve/v1.0.0/pt/pt_BR/faber/medium/pt_BR-faber-medium.onnx?download=true";
    const PIPER_CONFIG_URL = "https://huggingface.co/rhasspy/piper-voices/resolve/v1.0.0/pt/pt_BR/faber/medium/pt_BR-faber-medium.onnx.json?download=true";
    // Biblioteca do Piper (WASM) via CDN
    const PIPER_WASM_SCRIPT = "https://cdn.jsdelivr.net/npm/@buzzing/piper-synth-web@0.1.1/index.min.js";

    // 1. Injeta o script do Piper dinamicamente
    function loadPiperScript() {
        if (document.getElementById('piper-script')) return; // Já carregado
        
        showFeedback("Preparando motor de voz... ⏳", "gold");
        const script = document.createElement('script');
        script.id = 'piper-script';
        script.type = 'module';
        script.src = PIPER_WASM_SCRIPT;
        
        script.onload = () => {
            console.log("Piper Script Carregado. Inicializando...");
            initPiper();
        };
        script.onerror = () => {
            showFeedback("Erro ao carregar Piper. Verifique internet.", "red");
        };
        document.body.appendChild(script);
    }

    // 2. Inicializa o Worker do Piper
    async function initPiper() {
        if (isPiperLoading || piperWorker) return;
        isPiperLoading = true;
        
        try {
            // Importa a função da biblioteca carregada pelo CDN
            // Nota: Dependendo da CDN, a função pode estar global ou em módulo. 
            // Vamos usar uma abordagem genérica para carregar o worker.
            // Para simplificar em arquivo único, usaremos a API de áudio nativa com fallback se o Piper falhar
            // Mas vamos tentar configurar o worker manualmente aqui:
            
            showFeedback("Baixando voz neural (25MB)... Aguarde.", "gold");

            // Como o Piper via CDN em arquivo único é complexo, vamos usar o tts-server logic simplificado
            // Se falhar, usaremos o Nativo melhorado.
            
            // --- HACK PARA PROJETO DE ARQUIVO ÚNICO ---
            // O Piper exige Workers que não rodam bem em file:// sem configuração.
            // Vamos usar o truque do Blob para criar o Worker inline se possível, 
            // mas baixar 30MB toda vez é ruim para o usuário.
            
            // MUDANÇA DE ESTRATÉGIA PARA MÁXIMA COMPATIBILIDADE:
            // Vamos usar o SISTEMA NATIVO (SpeechSynthesis) mas forçando a voz "Google Português"
            // que é Neural e já vem no Chrome/Android, evitando o download de 30MB.
            
            throw new Error("Modo Simplificado Ativado");

        } catch (e) {
            console.log("Fallback para Voz Nativa Otimizada");
            isPiperLoading = false;
            // Se o Piper falhar (comum em arquivo local), inicializa o sistema nativo
            populateVoiceList();
        }
    }

    // --- SISTEMA HÍBRIDO (Tenta selecionar a melhor voz nativa Neural) ---
    
    // --- FUNÇÃO MELHORADA: MENUS DE VOZ COM MEMÓRIA ---
    // --- FUNÇÃO MELHORADA: MENUS DE VOZ DUPLA COM MEMÓRIA ---
    function populateVoiceList() {
        const voiceSelectQ = document.getElementById('voiceSelectQuestion');
        const voiceSelectA = document.getElementById('voiceSelectAnswer');
        
        // Se os elementos não existirem (ainda não carregou o modal), sai.
        if(!voiceSelectQ || !voiceSelectA) return;
        
        const voices = window.speechSynthesis.getVoices();
        
        // Limpa as listas
        voiceSelectQ.innerHTML = '';
        voiceSelectA.innerHTML = '';
        
        // Filtra vozes em Português e ordena (Google/Microsoft primeiro)
        const ptVoices = voices.filter(v => v.lang.includes('pt') || v.lang.includes('PT'));
        ptVoices.sort((a, b) => {
            const isGoodA = a.name.includes('Google') || a.name.includes('Microsoft') || a.name.includes('Luciana');
            const isGoodB = b.name.includes('Google') || b.name.includes('Microsoft') || b.name.includes('Luciana');
            return isGoodB - isGoodA; 
        });

        // Função auxiliar para criar as opções
        const createOptions = (selectElement) => {
            if(ptVoices.length === 0) {
                const option = document.createElement('option');
                option.textContent = "Padrão do Sistema";
                selectElement.appendChild(option);
            } else {
                ptVoices.forEach((voice) => {
                    const option = document.createElement('option');
                    option.textContent = voice.name + (voice.default ? ' (Padrão)' : '');
                    option.value = voice.name;
                    selectElement.appendChild(option);
                });
            }
        };

        // Preenche os dois menus
        createOptions(voiceSelectQ);
        createOptions(voiceSelectA);

        // --- RECUPERA AS ESCOLHAS SALVAS ---
        const savedVoiceQ = localStorage.getItem('chicoVoiceQ');
        const savedVoiceA = localStorage.getItem('chicoVoiceA');
        const oldSavedVoice = localStorage.getItem('chicoPreferredVoice'); // Migração do sistema antigo

        // Define Pergunta
        if (savedVoiceQ) {
            voiceSelectQ.value = savedVoiceQ;
        } else if (oldSavedVoice) {
            voiceSelectQ.value = oldSavedVoice; // Tenta usar a antiga se não tiver nova
        } else {
            voiceSelectQ.selectedIndex = 0;
        }

        // Define Resposta
        if (savedVoiceA) {
            voiceSelectA.value = savedVoiceA;
        } else if (oldSavedVoice) {
            voiceSelectA.value = oldSavedVoice;
        } else {
            voiceSelectA.selectedIndex = 0;
        }
        
        // --- EVENTOS DE SALVAMENTO ---
        voiceSelectQ.onchange = function() {
            localStorage.setItem('chicoVoiceQ', this.value);
            showFeedback("Voz da Pergunta definida! 🗣️", "gold");
        };
        voiceSelectA.onchange = function() {
            localStorage.setItem('chicoVoiceA', this.value);
            showFeedback("Voz da Resposta definida! 🗣️", "gold");
        };
    }

    // Garante que as vozes carreguem (Chrome precisa disso)
    if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = populateVoiceList;
    }

    const settingsBtn = document.getElementById('settingsBtn');
    if(settingsBtn) settingsBtn.addEventListener('click', populateVoiceList);

    // --- VARIÁVEIS E FUNÇÕES DO MODO MÃOS LIVRES (ATUALIZADO PARA GOOGLE SITES) ---
    let isHandsFree = false; 
    let handsFreeDelay = 3;
    let handsFreeTimer = null; 

    // 1. Função chamada ao clicar no botão de Voz
    function toggleSpeech() {
        // Se já estiver ligado, desliga imediatamente
        if (isAutoTTS) {
            isAutoTTS = false;
            isHandsFree = false;
            clearTimeout(handsFreeTimer);
            
            const btn = document.getElementById('ttsButton'); // Ícone, se houver
            const menuIcon = document.getElementById('menuTTSIcon');
            if(menuIcon) menuIcon.style.color = "#FFD700"; // Volta ao Dourado
            
            showFeedback("Leitura: DESLIGADA 🔇", "white");
            stopSpeech();
            return;
        }

        // Se estiver desligado, abre a Janela Personalizada (Modal)
        document.getElementById('handsFreeModal').style.display = 'flex';
        // Reseta o visual do modal para a etapa 1
        resetHfModal();
    }

    // 2. Funções auxiliares do Modal
    function closeHandsFreeModal() {
        document.getElementById('handsFreeModal').style.display = 'none';
    }

    function resetHfModal() {
        document.getElementById('hfStep1').style.display = 'block';
        document.getElementById('hfStep2').style.display = 'none';
    }

    function showHfStep2() {
        document.getElementById('hfStep1').style.display = 'none';
        document.getElementById('hfStep2').style.display = 'block';
        // Foca no campo de número para facilitar digitação
        setTimeout(() => document.getElementById('hfDelayInput').focus(), 100);
    }

    // 3. Opção: Apenas Ler (Manual)
    function startManualTTS() {
        closeHandsFreeModal();
        activateTTS(false, 0);
        showFeedback("Leitura: LIGADA (Manual) 🗣️", "#00ff00");
    }

    // 4. Opção: Mãos Livres (Automático)
    function startHandsFreeTTS() {
        const inputVal = document.getElementById('hfDelayInput').value;
        const delay = parseInt(inputVal) || 3;
        
        closeHandsFreeModal();
        activateTTS(true, delay);
        showFeedback(`Mãos Livres ATIVO (${delay}s) 🗣️`, "#00ff00");
    }

    // 5. Função interna que liga tudo
    function activateTTS(handsFreeMode, delayTime) {
        isAutoTTS = true;
        isHandsFree = handsFreeMode;
        handsFreeDelay = delayTime;
        
        const menuIcon = document.getElementById('menuTTSIcon');
        if(menuIcon) menuIcon.style.color = "#00ff00"; // Verde

        if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();
        speakCard();
    }

    function stopSpeech() {
        window.speechSynthesis.cancel();
    }
// --- DICIONÁRIO DE PRONÚNCIA (Mapa Fonético) ---
    // Adicione aqui as palavras que o robô lê errado.
    // Formato: "Palavra Escrita" : "Jeito que deve ser falado",
  // --- DICIONÁRIO DE PRONÚNCIA
    const pronunciationDict = {
        // === 1. SÍMBOLOS E PONTUAÇÃO ESPECIAL ===
        "§": "parágrafo",
        "n.º": "número",
        "nº": "número",
        "obs:": "observação",
        "etc.": "etcetera",
        "p. ex.": "por exemplo",
        "v.g.": "verbi gratia",
        "al.": "Alínea",

        // === 2. CÓDIGOS, LEIS E ESTATUTOS ===
        "CF/88": "Constituição Federal de oitenta e oito",
        "CF88": "Constituição Federal",
        "CC/02": "Código Civil de dois mil e dois",
        "CC": "Código Civil",
        "CPC": "Código de Processo Civil",
        "CPP": "Código de Processo Penal",
        "CP": "Código Penal",
        "CTB": "Código de Trânsito Brasileiro",
        "CLT": "Consolidação das Leis do Trabalho",
        "ECA": "Estatuto da Criança e do Adolescente",
        "CDC": "Código de Defesa do Consumidor",
        "LINDB": "Lei de Introdução às normas do Direito Brasileiro",
        "LEP": "Lei de Execução Penal",
        "Leman": "Lei do Mandado de Segurança",

        // === 3. TRIBUNAIS E ÓRGÃOS ===
        "TJMG": "Tribunal de Justiça de Minas Gerais",
        "STF": "Supremo Tribunal Federal",
        "STJ": "Superior Tribunal de Justiça",
        "TST": "Tribunal Superior do Trabalho",
        "TSE": "Tribunal Superior Eleitoral",
        "MP": "Ministério Público",
        "MPMG": "Ministério Público de Minas Gerais",
        "DPU": "Defensoria Pública da União",
        "AGU": "Advocacia Geral da União",
        "PM": "Polícia Militar",
        "PC": "Polícia Civil",
        "PF": "Polícia Federal",
        "PRF": "Polícia Rodoviária Federal",
        "11 RPM": "Décima primeira região da polícia militar",
        "RPM": "Região da Polícia Militar",

        // === 4. RECURSOS E AÇÕES ===
        "Habeas Corpus": "Ábeas Corpus",
        "Habeas Data": "Ábeas Data",
        "Mandado de Segurança": "Mandado de Segurança",
        "ADIn": "Ação Direta de Inconstitucionalidade",
        "ADC": "Ação Declaratória de Constitucionalidade",
        "ADPF": "Arguição de Descumprimento de Preceito Fundamental",
        "RE": "Recurso Extraordinário",
        "REsp": "Recurso Especial",
        "Writ": "Ruit", // Pronúncia afrancesada comum no direito ou "rit" do inglês
        
        // === 5. TERMOS EM LATIM (Pronúncia aportuguesada) ===
        "caput": "cáput",
        "in fine": "in fíne",
        "vacatio legis": "vacátio légis",
        "ex tunc": "ex túnc", // Retroage
        "ex nunc": "ex núnc", // Não retroage
        "erga omnes": "érga ômnes",
        "inter partes": "ínter pártes",
        "bis in idem": "bis in ídem",
        "periculum in mora": "perículum in móra",
        "fumus boni iuris": "fúmus bôni iúris",
        "custos legis": "cústos légis",
        "data venia": "dáta vênia",

        // === 6. ABREVIAÇÕES DE TEXTO DE LEI ===
        "Art.": "Artigo",
        "art.": "Artigo",
        "Arts.": "Artigos",
        "arts.": "Artigos",
        "Inc.": "Inciso",
        "inc.": "Inciso",
        "Par.": "Parágrafo",
        "par.": "Parágrafo",
        "pg.": "Parágrafo",

        // === 7. NÚMEROS ROMANOS (Expandido) ===
        // A lógica agressiva garante que XVIII seja lido antes de V
        "XVIII": "dezoito",
        "XVII": "dezessete",
        "XVI": "dezesseis",
        "VIII": "oito",
        "XIII": "treze",
        "XXX": "trinta",
        "XIV": "quatorze",
        "XIX": "dezenove",
        "XX": "vinte",
        "XV": "quinze",
        "XII": "doze",
        "VII": "sete",
        "III": "três",
        "IV": "quatro",
        "VI": "seis",
        "IX": "nove",
        "XI": "onze",
        "XL": "quarenta",
        "XC": "noventa",
        "II": "dois",
        "V": "cinco",
        "X": "dez",
        "L": "cinquenta",
        "C": "cem",
        "I": "um" // Cuidado: No contexto de Flashcards, I maiúsculo isolado geralmente é numeral.
    };

    function applyPhoneticCorrections(text) {
        if (!text) return "";
        let correctedText = text;
        
        // 1. Ordena as chaves pelo tamanho (do maior para o menor)
        // Isso garante que "CF/88" seja processado antes de "CF", evitando erros.
        const sortedKeys = Object.keys(pronunciationDict).sort((a, b) => b.length - a.length);

        for (let original of sortedKeys) {
            const phonetic = pronunciationDict[original];
            
            // Escapa caracteres especiais para o Regex não quebrar (como pontos e barras)
            const safeOriginal = original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            let regex;

            // --- LÓGICA DA AGRESSIVIDADE ---
            // Verifica se o termo original é composto APENAS por letras/números (Ex: MP, STF, Writ)
            if (/^[a-zA-Z0-9À-ÿ]+$/.test(original)) {
                // Se for palavra limpa, usamos SEGURANÇA (\b) para não substituir o meio de outras palavras
                // Ex: Evita que "MP" substitua "caMPo"
                regex = new RegExp(`\\b${safeOriginal}\\b`, "gi");
            } else {
                // Se tiver ponto, barra ou espaço (Ex: art., CF/88, 11 RPM), ativamos o MODO AGRESSIVO.
                // Removemos a fronteira (\b) porque o ponto muitas vezes já é a fronteira.
                regex = new RegExp(safeOriginal, "gi");
            }

            correctedText = correctedText.replace(regex, phonetic);
        }
        return correctedText;
    }
    function speakCard() {
        if (!initialCards || initialCards.length === 0) return;
        if (!isAutoTTS) return; 

        // Segurança: Limpa timer anterior para não pular cards errados
        clearTimeout(handsFreeTimer);
        stopSpeech();

        // 1. Prepara o Texto
        let rawText = showingFront ? cards[currentCard].front : cards[currentCard].back;
        
        // Limpeza visual (remove HTML, chaves, asteriscos)
        let cleanText = rawText.replace(/{{|}}/g, "")
                             .replace(/\*/g, "")
                             .replace(/<[^>]*>/g, "")
                             .replace(/&nbsp;/g, " ");
        // --- FILTRO ANTI-EMOJI (Remove carinhas e símbolos gráficos para leitura) ---
        cleanText = cleanText.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2700}-\u{27BF}]|[\u{2600}-\u{26FF}]|[\u{1F1E0}-\u{1F1FF}]/gu, "");
        // APLICA A CORREÇÃO FONÉTICA (Dicionário)
        let textToRead = applyPhoneticCorrections(cleanText);

        // 2. Configura a Fala Nativa
        const utterance = new SpeechSynthesisUtterance(textToRead);
        
        // Pega a voz escolhida pelo usuário
        // --- LÓGICA DE VOZ DUPLA (PERGUNTA vs RESPOSTA) ---
        const voices = window.speechSynthesis.getVoices();
        let selectedName = "";

        // Se estiver mostrando a FRENTE, usa a voz da Pergunta. Senão, Resposta.
        if (showingFront) {
            const vQ = document.getElementById('voiceSelectQuestion');
            selectedName = vQ ? vQ.value : "";
        } else {
            const vA = document.getElementById('voiceSelectAnswer');
            selectedName = vA ? vA.value : "";
        }

        // Tenta encontrar a voz escolhida
        const chosenVoice = voices.find(v => v.name === selectedName);

        if (chosenVoice) {
            utterance.voice = chosenVoice;
        } else {
            // Fallback inteligente (Se a voz sumiu, tenta a melhor disponível)
            const bestVoice = voices.find(v => (v.lang.includes('pt') && (v.name.includes('Google') || v.name.includes('Microsoft'))));
            if (bestVoice) utterance.voice = bestVoice;
        }

        // Configura velocidade
        const rateRange = document.getElementById('rateRange');
        utterance.rate = rateRange ? parseFloat(rateRange.value) : 1.1;
        utterance.pitch = 1.0;

        // Correção de Bug do Chrome (Keep Alive)
        utterance.onboundary = function(event) { /* keep alive */ };
        
        // --- NOVA LÓGICA: O QUE FAZER QUANDO TERMINAR DE FALAR ---
        utterance.onend = function(event) {
            if (isHandsFree && isAutoTTS) {
                // Aguarda o tempo definido pelo usuário e avança
                handsFreeTimer = setTimeout(() => {
                    // Verifica novamente se ainda estamos no modo auto (usuário pode ter cancelado nesse meio tempo)
                    if (isHandsFree && isAutoTTS) {
                        reviewAndAdvance();
                    }
                }, handsFreeDelay * 1000); // Converte segundos para milissegundos
            }
        };
        // ---------------------------------------------------------

        utterance.onerror = function(e) {
            console.error("Erro na fala:", e);
            // Se der erro, tenta reiniciar a lista de vozes
            populateVoiceList();
        };

        // --- CORREÇÃO DE CORTE DE ÁUDIO ---
        // Adiciona um pequeno atraso (100ms) para garantir que o navegador 
        // limpou o buffer de áudio anterior antes de começar o próximo.
        setTimeout(() => {
            window.speechSynthesis.speak(utterance);
        }, 100);
    }

    // Inicialização segura
    document.addEventListener("DOMContentLoaded", () => {
        populateVoiceList();
        // Recarrega vozes após 1s para garantir que o navegador baixou a lista
        setTimeout(populateVoiceList, 1000);
    });
    // --- INICIALIZAÇÃO ---
   document.addEventListener("keydown", (e) => {
  
  const loginModal = document.getElementById('loginModal');
  if (window.getComputedStyle(loginModal).display === 'flex') {
    return;
  }
  const activeElement = document.activeElement;
  const isInputFocused = activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT';
  if (isInputFocused) {
    return;
  }
 if (e.key === "s" || e.key === "S") {
    e.preventDefault();
    toggleSpeech();
  }
  // --- Atalhos do temporizador (devem vir ANTES dos demais) ---
  if (e.key === "p" || e.key === "P") {
    e.preventDefault();
    if (isAutoAdvanceActive) {
      pauseOrResumeAutoAdvance();
    }
  }
  if (e.key === "r" || e.key === "R") {
    e.preventDefault();
    if (isAutoAdvanceActive) {
      resetAutoAdvanceTimer();
      showFeedback("Temporizador resetado!", "gold");
    }
  }
  if (e.key === "t" || e.key === "T") {
    e.preventDefault();
    openAutoAdvanceSettings();
  }

  // --- Demais atalhos ---
  if (e.key === "Enter") {
    e.preventDefault();
    reviewAndAdvance();
  }
  if (e.key === "Alt") {
    e.preventDefault();
    reviewAndRetreat();
  }
  // --- ATALHOS DE RESPOSTA (INTELIGENTES) ---
  if (e.key === "1") {
    e.preventDefault();
    if (typeof isSRSMode !== 'undefined' && isSRSMode) {
        // Modo SRS: Tecla 1 = Errei (Again)
        const btn = document.getElementById('btnAgain');
        rateCardSRS('again', btn, '#ff5555');
    } else {
        // Modo Normal: Tecla 1 = Acertei
        markAsCorrect();
    }
  }
  if (e.key === "2") {
    e.preventDefault();
    if (typeof isSRSMode !== 'undefined' && isSRSMode) {
        // Modo SRS: Tecla 2 = Difícil (Hard)
        const btn = document.getElementById('btnHard');
        rateCardSRS('hard', btn, '#ffa500');
    } else {
        // Modo Normal: Tecla 2 = Errei
        markAsIncorrect();
    }
  }
  if (e.key === "3") {
    e.preventDefault();
    if (typeof isSRSMode !== 'undefined' && isSRSMode) {
        // Modo SRS: Tecla 3 = Bom (Good)
        const btn = document.getElementById('btnGood');
        rateCardSRS('good', btn, '#90ee90');
    }
  }
  if (e.key === "4") {
    e.preventDefault();
    if (typeof isSRSMode !== 'undefined' && isSRSMode) {
        // Modo SRS: Tecla 4 = Fácil (Easy)
        const btn = document.getElementById('btnEasy');
        rateCardSRS('easy', btn, '#00ff00');
    }
  }
  // --- NOVO: ATALHO TECLA 0 (NÃO SEI) ---
  if (e.key === "0") {
    e.preventDefault();
    if (typeof isSRSMode !== 'undefined' && isSRSMode) {
        // Aciona o botão Roxo "Não Sei"
        const btn = document.getElementById('btnDontKnow');
        rateCardSRS('again', btn, '#d8bfd8'); 
    } else {
        // Se não estiver no SRS, age como "Errei" padrão
        markAsIncorrect();
    }
  }
  // --- ATALHOS DE FONTE ---
  if (e.key === "+" || e.key === "=") { // Aceita + ou = (tecla comum sem shift)
    e.preventDefault();
    adjustFontSize(1);
  }
 if (e.key === "-" || e.key === "_") { // Aceita - ou _
    e.preventDefault();
    adjustFontSize(-1);
  }
  // --- NOVO ATALHO: Tecla Asterisco (*) ---
  if (e.key === "*") {
    e.preventDefault();
    toggleHighlightAsterisks();
  }
  // ----------------------------------------
  if (e.key === " ") {
    e.preventDefault();
  }
});

    setInterval(updateTimer, 1000);

    document.getElementById('loginForm').addEventListener('submit', login);

    document.addEventListener('DOMContentLoaded', checkAuthentication);

    document.getElementById('restart-button').addEventListener('click', restartFlashcards);

    document.getElementById('review-errors-button').addEventListener('click', reviewErrorsFromEndScreen);
       function toggleHighlightAsterisks() {
      isHighlightModeActive = !isHighlightModeActive;
      const feedback = document.getElementById("highlightFeedback");
      
      if (isHighlightModeActive) {
        applyAsteriskHighlight();
        feedback.textContent = "Destaque ATIVADO";
        feedback.style.color = "#4CAF50"; // Verde
      } else {
        const contentElement = document.getElementById("flashcard-content");
        const currentText = showingFront ? cards[currentCard].front : cards[currentCard].back;
        contentElement.textContent = currentText;
        feedback.textContent = "Destaque DESATIVADO";
        feedback.style.color = "#F44336"; // Vermelho
      }
      
      // Mostrar feedback
      feedback.style.opacity = "1";
      setTimeout(() => {
        feedback.style.opacity = "0";
      }, 1500);
    }

        function applyAsteriskHighlight() {
      if (!requireAuth() || cards.length === 0 || !isHighlightModeActive) return;
      const container = document.getElementById("card-container");
      const contentElement = document.getElementById("flashcard-content");
      const currentText = showingFront ? cards[currentCard].front : cards[currentCard].back;
      const bgColor = window.getComputedStyle(container).backgroundColor;
      const isBlackBackground = (bgColor === 'rgb(0, 0, 0)' || bgColor === 'black');

      // Divide o texto mantendo os asteriscos como delimitadores
      const parts = currentText.split(/(\*[^*]+\*)/g);
      let result = '';
      let matchCount = 0;

      parts.forEach(part => {
        if (part.startsWith('*') && part.endsWith('*') && part.length > 2) {
          matchCount++;
          let className;
          if (isBlackBackground) {
            className = (matchCount % 2 === 1) 
              ? 'highlight-asterisk-gold-alt1' 
              : 'highlight-asterisk-gold-alt2';
          } else {
            className = (matchCount % 2 === 1) 
              ? 'highlight-asterisk-alt1' 
              : 'highlight-asterisk-alt2';
          }
          result += `<span class="${className}">${part}</span>`;
        } else {
          // Escapa HTML para evitar injeção acidental
result += part.replace(/&/g, '&amp;') 
             .replace(/</g, '&lt;') 
             .replace(/>/g, '&gt;') 
             .replace(/"/g, '&quot;') 
             .replace(/'/g, '&#039;')
             .replace(/\*/g, '&#42;'); // Trata * solto como caractere literal
        }
      });

      contentElement.innerHTML = result;
    }
	function startAutoAdvanceWithDelay(delay) {
  if (!requireAuth()) return;
  lastAutoAdvanceDelay = delay;
  autoAdvanceDelay = delay;
  isAutoAdvanceActive = true;
  isAutoAdvancePaused = false;
  autoAdvanceSeconds = autoAdvanceDelay;
  updateAutoAdvanceDisplay();
  updateAutoAdvanceUI(); // ← Mostra os botões de controle
  autoAdvanceInterval = setInterval(() => {
    if (isAutoAdvancePaused) return;
    autoAdvanceSeconds--;
    updateAutoAdvanceDisplay();
    if (autoAdvanceSeconds <= 0) {
      reviewAndAdvance();
      autoAdvanceSeconds = autoAdvanceDelay;
      updateAutoAdvanceDisplay();
    }
  }, 1000);
}

function pauseAutoAdvance() {
  if (!isAutoAdvanceActive || isAutoAdvancePaused) return;
  isAutoAdvancePaused = true;
  clearInterval(autoAdvanceInterval);
  document.getElementById('pauseResumeBtn').textContent = "▶️";
  autoAdvanceTimerDisplay.textContent = `${autoAdvanceSeconds}s`;
  autoAdvanceTimerDisplay.style.color = "#FFD700"; // Amarelo ao pausar
}

function resumeAutoAdvance() {
  if (!isAutoAdvanceActive || !isAutoAdvancePaused) return;
  isAutoAdvancePaused = false;
  autoAdvanceInterval = setInterval(() => {
    if (isAutoAdvancePaused) return;
    autoAdvanceSeconds--;
    updateAutoAdvanceDisplay();
    if (autoAdvanceSeconds <= 0) {
      reviewAndAdvance();
      autoAdvanceSeconds = autoAdvanceDelay;
      updateAutoAdvanceDisplay();
    }
  }, 1000);
  document.getElementById('pauseResumeBtn').textContent = "⏸️";
  updateAutoAdvanceDisplay();
  autoAdvanceTimerDisplay.style.color = "white"; // Volta à cor normal
}

function resetAutoAdvanceTimer() {
  if (!isAutoAdvanceActive) return;
  autoAdvanceSeconds = autoAdvanceDelay;
  updateAutoAdvanceDisplay();
  if (isAutoAdvancePaused) {
    resumeAutoAdvance();
    pauseAutoAdvance(); // Mantém pausado, mas reseta o tempo
  }
}

function showFeedback(message, color = "gold") {
  const feedback = document.createElement('div');
  feedback.textContent = message;
  feedback.style.position = 'fixed';
  feedback.style.top = '50%';
  feedback.style.left = '50%';
  feedback.style.transform = 'translate(-50%, -50%)';
  feedback.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
  feedback.style.color = color;
  feedback.style.padding = '10px 20px';
  feedback.style.borderRadius = '8px';
  feedback.style.zIndex = '10002';
  feedback.style.fontSize = '1.2em';
  feedback.style.pointerEvents = 'none';
  document.body.appendChild(feedback);
  setTimeout(() => document.body.removeChild(feedback), 1500);
}
// Função principal para iniciar o temporizador com o último tempo usado
function startAutoAdvanceSmart() {
  if (!requireAuth()) return;
  if (lastAutoAdvanceDelay > 0) {
    startAutoAdvanceWithDelay(lastAutoAdvanceDelay);
  } else {
    openAutoAdvanceSettings();
  }
}

// Alternar entre pausar e continuar
function pauseOrResumeAutoAdvance() {
  if (!isAutoAdvanceActive) return;
  if (isAutoAdvancePaused) {
    resumeAutoAdvance();
    document.getElementById('pauseResumeBtn').textContent = '⏸️';
  } else {
    pauseAutoAdvance();
    document.getElementById('pauseResumeBtn').textContent = '▶️';
  }
}

// Abrir o modal de configuração (sem parar tudo)
function openAutoAdvanceSettings() {
  if (!requireAuth()) return;
  if (isAutoAdvanceActive) {
    pauseOrResumeAutoAdvance(); // Pausa antes de configurar
  }
  document.getElementById("autoAdvanceDelayInput").value = lastAutoAdvanceDelay || autoAdvanceDelay;
  document.getElementById("autoAdvanceSetup").style.display = "flex";
  document.getElementById("autoAdvanceOverlay").style.display = "block";
}

// Atualiza a visibilidade dos botões (INICIAR vs CONTROLE)
function updateAutoAdvanceUI() {
  const startBtn = document.getElementById('autoAdvanceStartBtn');
  const activeGroup = document.getElementById('autoAdvanceActiveGroup');
  if (isAutoAdvanceActive) {
    startBtn.style.display = 'none';
    activeGroup.style.display = 'flex';
  } else {
    startBtn.style.display = 'inline-block';
    activeGroup.style.display = 'none';
  }
}
// --- FUNÇÕES PARA O NOVO MODAL DE CONFIGURAÇÕES ---

    // Abre a janela de configurações
   function openSettingsModal() {
      if (!isAuthenticated || initialCards.length === 0) return;
      
      // Preenche as opções de disciplina e ano com base nos cards carregados
      populateDisciplineDropdowns(initialCards);
      populateAnoDropdowns(initialCards);
      
      document.getElementById('settingsModal').style.display = 'flex';
    }

    // Fecha a janela de configurações
    function closeSettingsModal() {
      document.getElementById('settingsModal').style.display = 'none';
    }
// INÍCIO DA NOVA FUNÇÃO
    // Mostra ou oculta as opções de peso mínimo com base na seleção do rádio
    function switchWeightMode(mode) {
      document.getElementById('pesoMinimoOptions').style.display = (mode === 'minimo') ? 'block' : 'none';
    }
    // FIM DA NOVA FUNÇÃO
    // Alterna a exibição das opções entre "Simulado" e "Provas"
   // Alterna a exibição das opções e CARREGA as disciplinas (VERSÃO ATUALIZADA)
   function switchStudyMode(mode) {
      // 1. Esconde TODAS as opções da etapa 2
      document.getElementById('simuladoOptions').style.display = 'none';
      document.getElementById('provasOptions').style.display = 'none';
      document.getElementById('livreOptions').style.display = 'none';

      // 2. Mostra APENAS a opção selecionada
      if (mode === 'simulado') {
          document.getElementById('simuladoOptions').style.display = 'block';
      } else if (mode === 'provas') {
          document.getElementById('provasOptions').style.display = 'block';
     } else if (mode === 'livre') {
          document.getElementById('livreOptions').style.display = 'block';
      }

      // LÓGICA AUTOMÁTICA PARA SRS
      if (mode === 'srs') {
        // Marca automaticamente a opção "Sequencial" na etapa 3
        const seqBtn = document.querySelector('input[name="weightMode"][value="sequencial"]');
        if (seqBtn) {
            seqBtn.checked = true;
            switchWeightMode('sequencial'); // Garante que esconde opções de peso mínimo
        }
      }
    }

    // Função principal que inicia o estudo com base nas configurações escolhidas
   // Função principal que inicia o estudo com base nas configurações escolhidas (VERSÃO ATUALIZADA)
    // Função principal que inicia o estudo (VERSÃO ATUALIZADA E SIMPLIFICADA)
    // Função principal que inicia o estudo (VERSÃO ATUALIZADA E SIMPLIFICADA)
// --- FUNÇÕES DO ALERTA PERSONALIZADO ---
function showCustomAlert(msg) {
  document.getElementById('customAlertMessage').textContent = msg;
  document.getElementById('customAlertModal').style.display = 'flex';
}

function closeCustomAlert() {
  document.getElementById('customAlertModal').style.display = 'none';
}

function startCustomStudy() {
  // 1. Validação de Segurança: O usuário selecionou um modo?
  const modeEl = document.querySelector('input[name="studyMode"]:checked');
  if (!modeEl) {
    // Substituído alert() por showCustomAlert()
    showCustomAlert("Por favor, selecione um Modo de Estudo (Item 1) antes de iniciar.");
    return;
  }
  
  // 2. Validação de Segurança: O usuário selecionou um peso? (Exceto se for SRS)
  const weightEl = document.querySelector('input[name="weightMode"]:checked');
  if (!weightEl && modeEl.value !== 'srs') { 
    // Substituído alert() por showCustomAlert()
    showCustomAlert("Por favor, selecione uma opção de Pesos (Item 3) para continuar.");
    return;
  }
  const studyMode = modeEl.value;
  
  closeSettingsModal();
  showLoadingIndicator(`Iniciando ${studyMode}...`);
  
  try {
    let filteredCards = []; // Cards candidatos
    
    // --- MODO 1: SIMULADO (Por disciplina específica) ---
    if (studyMode === 'simulado') {
      const simuladoPool = initialCards.filter(card => !card.tipo.includes('prova'));
      const config = [];
      const rows = document.querySelectorAll('#simuladoDisciplineInputs .discipline-row');
      rows.forEach(row => {
        const disciplina = row.querySelector('.discipline-select').value;
        const quantidade = parseInt(row.querySelector('.quantity-input').value);
        if (disciplina && quantidade > 0) {
          config.push({ disciplina, quantidade });
        }
      });
      cards = generateCustomDeck(simuladoPool, config);

    // --- MODO 2: ESTUDO LIVRE (Aleatório Geral) ---
    } else if (studyMode === 'livre') {
       const fullPool = initialCards.filter(card => !card.tipo.includes('prova'));
       const qtdDesejada = parseInt(document.getElementById('livreQuantity').value) || 20;
       
       // Verifica qual modo de peso/ordem foi escolhido no Item 3
       const weightMode = document.querySelector('input[name="weightMode"]:checked').value;

       if (weightMode === 'sequencial') {
           // SE FOR SEQUENCIAL: Pega as primeiras X questões na ordem exata da planilha
           cards = fullPool.slice(0, qtdDesejada);
       } else {
           // SE FOR ALEATÓRIO/PONDERADO: Faz o sorteio baseado nos pesos
           let weightedPool = [];
           const isFocusEnabled = document.getElementById('enableFocusMode').checked;

           fullPool.forEach(card => {
              let finalWeight = card.peso || 1;
              if (isFocusEnabled && userLearningStats.topicWeights && userLearningStats.topicWeights[card.topico]) {
                  finalWeight += Math.floor(userLearningStats.topicWeights[card.topico]);
              }
              finalWeight = Math.min(finalWeight, 10);
              for(let i=0; i<finalWeight; i++) weightedPool.push(card);
           });

           // Embaralha o pool para sorteio
           for (let i = weightedPool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [weightedPool[i], weightedPool[j]] = [weightedPool[j], weightedPool[i]];
           }

           const selectedSet = new Set();
           for (const c of weightedPool) {
               if (selectedSet.size < qtdDesejada) selectedSet.add(c);
               else break;
           }
           cards = Array.from(selectedSet);
       }
       cards = Array.from(selectedSet);
// --- NOVO MODO: SRS (Repetição Espaçada) ---
    } else if (studyMode === 'srs') {
        isSRSMode = true;
        const now = new Date();
        
        // Filtra: Cards sem registro (Novos) OU Cards Vencidos (Data <= Hoje)
        cards = initialCards.filter(card => {
            const id = generateCardId(card.front);
            const progress = userSRSProgress[id];
            
            if (!progress || !progress.nextReview) return true; // É novo
            return new Date(progress.nextReview) <= now; // Venceu
        });
        
        if (cards.length === 0) {
            showCustomAlert("Parabéns! Você está em dia com as revisões. Nada para estudar agora.");
            hideLoadingIndicator();
            return;
        }
        
        // Ordena: Vencidos há mais tempo aparecem primeiro
        cards.sort((a, b) => {
             const idA = generateCardId(a.front);
             const idB = generateCardId(b.front);
             const dateA = userSRSProgress[idA] ? new Date(userSRSProgress[idA].nextReview) : new Date(0);
             const dateB = userSRSProgress[idB] ? new Date(userSRSProgress[idB].nextReview) : new Date(0);
             return dateA - dateB;
        });
    // --- MODO 3: PROVAS ---
    } else { 
      filteredCards = initialCards.filter(card => card.tipo === 'Prova');
      const selectedYear = document.getElementById('provasAno').value;
      if (selectedYear !== 'todos') {
        cards = filteredCards.filter(card => card.ano === selectedYear);
      } else {
        cards = filteredCards;
      }
    }

    // --- FILTRO DE PESO MÍNIMO (Só se aplica se NÃO for ponderado, pois o ponderado já foi feito acima) ---
    // Nota: No 'simulado' e 'livre', a gente já usou o peso para selecionar.
    // Mas se o usuário marcou "Peso Mínimo", temos que cortar quem tem peso baixo.
    const weightMode = document.querySelector('input[name="weightMode"]:checked').value;
    if (weightMode === 'minimo') {
      const minWeight = parseInt(document.getElementById('pesoMinimoValue').value) || 1;
      cards = cards.filter(card => card.peso >= minWeight);
    }
    
    if (cards.length === 0) {
      document.getElementById("flashcard-content").textContent = "Nenhum card encontrado para os critérios selecionados.";
      cardCounter.textContent = "0/0";
    } else {
      currentCard = 0;
      showingFront = true;
      isFinished = false;
      // Embaralha final para garantir mistura
      currentCard = 0;
      showingFront = true;
      isFinished = false;
      
      // LÓGICA DE EMBARALHAMENTO
      // Só embaralha se o modo NÃO for "sequencial"
      const weightMode = document.querySelector('input[name="weightMode"]:checked').value;
     if (weightMode !== 'sequencial') {
          // Usa o novo sistema inteligente em vez do aleatório simples
          cards = smartShuffle(cards);
      }
      updateCard();
      saveFlashcardState();
    }
  } catch (error) {
    console.error("Erro ao iniciar estudo:", error);
    document.getElementById("flashcard-content").textContent = "Falha ao carregar os cards.";
  } finally {
    hideLoadingIndicator();
  }
}
	// --- NOVAS FUNÇÕES PARA GERENCIAR O SIMULADO ---

    // Adiciona uma nova linha para selecionar disciplina e quantidade
    function addDisciplineRow() {
      const container = document.getElementById('simuladoDisciplineInputs');
      const firstRow = container.querySelector('.discipline-row');
      const newRow = firstRow.cloneNode(true); // Clona a primeira linha
      
      // Limpa os valores do clone
      newRow.querySelector('.discipline-select').selectedIndex = 0;
      newRow.querySelector('.quantity-input').value = '';
      
      container.appendChild(newRow);
    }

    // Preenche as listas de seleção com as disciplinas encontradas na planilha
    function populateDisciplineDropdowns(allCards) {
      const disciplines = [...new Set(allCards.map(card => card.disciplina))].sort();
      const selects = document.querySelectorAll('.discipline-select');
      
      selects.forEach(select => {
        // Guarda a opção selecionada, se houver
        const selectedValue = select.value;
        // Limpa opções antigas, exceto a primeira ("Selecione...")
        while (select.options.length > 1) {
          select.remove(1);
        }
        // Adiciona as novas disciplinas
        disciplines.forEach(disc => {
          const option = document.createElement('option');
          option.value = disc;
          option.textContent = disc;
          select.appendChild(option);
        });
        // Restaura a seleção anterior
        select.value = selectedValue;
      });
    }

    // Atualiza o contador de total de questões
    function updateTotalQuestions() {
      let total = 0;
      const inputs = document.querySelectorAll('#simuladoDisciplineInputs .quantity-input');
      inputs.forEach(input => {
        total += parseInt(input.value) || 0;
      });
      document.getElementById('totalSimuladoQuestions').textContent = total;
    }

    // Gera o baralho customizado com base na seleção do usuário
    function generateCustomDeck(allCards, config) {
      let finalDeck = [];
      
      // Agrupa todos os cards por disciplina
      const cardsByDiscipline = allCards.reduce((acc, card) => {
        if (!acc[card.disciplina]) {
          acc[card.disciplina] = [];
        }
        acc[card.disciplina].push(card);
        return acc;
      }, {});

      // Para cada configuração do usuário (ex: Português, 10 questões)
      config.forEach(item => {
        const disciplineCards = cardsByDiscipline[item.disciplina];
        if (!disciplineCards) return;

        // Cria uma "piscina" de sorteio ponderada pelo peso + APRENDIZADO ADAPTATIVO
        let weightedPool = [];
        disciplineCards.forEach(card => {
          // Pega o peso original da planilha
          let finalWeight = card.peso || 1;
          
          // ADAPTATIVO: Soma o peso extra baseado no Tópico (Coluna E)
          // O código usa 'card.categoria' para ler a Coluna E
          if (userLearningStats.topicWeights[card.categoria]) {
              finalWeight += Math.floor(userLearningStats.topicWeights[card.categoria]);
          }

          // Limite de segurança para não repetir exageradamente (máx 10x)
          finalWeight = Math.min(finalWeight, 10);

          for (let i = 0; i < finalWeight; i++) {
            weightedPool.push(card);
          }
        });
        
        // Embaralha a piscina ponderada
        for (let i = weightedPool.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [weightedPool[i], weightedPool[j]] = [weightedPool[j], weightedPool[i]];
        }

        // Seleciona o número de cards desejado, sem duplicatas
        const selectedForDiscipline = new Set();
        for(const card of weightedPool) {
            if (selectedForDiscipline.size < item.quantidade) {
                selectedForDiscipline.add(card);
            } else {
                break;
            }
        }
        finalDeck.push(...Array.from(selectedForDiscipline));
      });

      return finalDeck;
    }
	// Preenche a lista de seleção com os anos encontrados na planilha de provas
    function populateAnoDropdowns(allCards) {
      // Pega apenas os anos únicos dos cards de "Prova" e remove valores vazios
      const anos = [...new Set(allCards.filter(c => c.tipo === 'Prova' && c.ano).map(card => card.ano))].sort((a, b) => b - a); // Ordena do mais novo para o mais antigo
      const select = document.getElementById('provasAno');
      
      // Limpa opções antigas, exceto a primeira ("Todos os Anos")
      while (select.options.length > 1) {
        select.remove(1);
      }
      
      // Adiciona os novos anos
      anos.forEach(ano => {
        const option = document.createElement('option');
        option.value = ano;
        option.textContent = ano;
        select.appendChild(option);
      });
    }
	// --- PAUSA INTELIGENTE ---
    // Se o usuário trocar de aba ou minimizar, pausa o cronômetro
    document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
            // Usuário saiu: Pausa o tempo
            if (cardViewStartTime > 0) {
                // Guarda quanto tempo já passou até agora numa variável temporária
                const elapsed = Date.now() - cardViewStartTime;
                sessionStorage.setItem('pausedTime', elapsed);
                cardViewStartTime = 0; // Zera para não continuar contando
                document.title = "⏸️ Pausado - Chico Concursos";
            }
        } else {
            // Usuário voltou: Retoma o tempo
            const pausedElapsed = parseInt(sessionStorage.getItem('pausedTime') || '0');
            if (pausedElapsed > 0) {
                // "Volta no tempo" para simular que o relógio continuou de onde parou
                cardViewStartTime = Date.now() - pausedElapsed;
                sessionStorage.removeItem('pausedTime');
                document.title = "Chico Concursos - Flashcards";
            }
        }
    });
	// --- LÓGICA DO MODAL DE FILTRO INTELIGENTE ---

    // 1. Abrir o Modal e Preencher Disciplinas
    // 1. Abrir o Modal e Restaurar Última Escolha
    function openFilterModal() {
      if (!requireAuth()) return;
      
      const modal = document.getElementById('filterModal');
      const discSelect = document.getElementById('modalDisciplineSelect');
      
      // Busca disciplinas únicas
      const uniqueDisc = [...new Set(initialCards.map(c => c.disciplina).filter(d => d))].sort();
      
      discSelect.innerHTML = '<option value="">Selecione a Disciplina...</option>';
      uniqueDisc.forEach(disc => {
        const option = document.createElement('option');
        option.value = disc;
        option.textContent = disc;
        discSelect.appendChild(option);
      });

      // Reseta visualização inicial
      document.getElementById('modalTopicContainer').style.display = 'none';
      document.getElementById('modalFocoContainer').style.display = 'none';

      // --- LÓGICA DE MEMÓRIA: Restaura a seleção anterior se houver ---
      if (lastFilterSelections.discipline) {
          discSelect.value = lastFilterSelections.discipline;
          
          // Força o carregamento dos tópicos baseados na disciplina salva
          modalHandleDisciplineChange(lastFilterSelections.discipline);
          
          if (lastFilterSelections.topic) {
              const topicSelect = document.getElementById('modalTopicSelect');
              topicSelect.value = lastFilterSelections.topic;
              
              // Força o carregamento dos focos baseados no tópico salvo
              modalHandleTopicChange(lastFilterSelections.topic);
              
              if (lastFilterSelections.foco) {
                  const focoSelect = document.getElementById('modalFocoSelect');
                  // Verifica se a opção ainda existe antes de selecionar
                  if (focoSelect.querySelector(`option[value="${lastFilterSelections.foco}"]`)) {
                      focoSelect.value = lastFilterSelections.foco;
                  }
              }
          }
      }
      // -------------------------------------------------------------

      modal.style.display = 'flex';
    }

    // 2. Fechar Modal
    function closeFilterModal() {
      document.getElementById('filterModal').style.display = 'none';
    }

    // 3. Ao escolher Disciplina -> Carrega Tópicos
    function modalHandleDisciplineChange(selectedDisc) {
      const topicContainer = document.getElementById('modalTopicContainer');
      const topicSelect = document.getElementById('modalTopicSelect');
      const focoContainer = document.getElementById('modalFocoContainer');

      // Reseta os passos seguintes
      topicContainer.style.display = 'none';
      focoContainer.style.display = 'none';

      if (!selectedDisc) return;

      // Filtra tópicos apenas desta disciplina
      const cardsOfDisc = initialCards.filter(c => c.disciplina === selectedDisc);
      const uniqueTopics = [...new Set(cardsOfDisc.map(c => c.topico).filter(t => t))].sort();

      topicSelect.innerHTML = '<option value="todos">Todos os Tópicos</option>';
      uniqueTopics.forEach(topic => {
        const option = document.createElement('option');
        option.value = topic;
        option.textContent = topic;
        topicSelect.appendChild(option);
      });

      topicContainer.style.display = 'block';
    }

    // 4. Ao escolher Tópico -> Verifica se precisa mostrar Foco
    function modalHandleTopicChange(selectedTopic) {
      const focoContainer = document.getElementById('modalFocoContainer');
      const focoSelect = document.getElementById('modalFocoSelect');
      const selectedDisc = document.getElementById('modalDisciplineSelect').value;

      focoContainer.style.display = 'none';

      if (!selectedTopic || selectedTopic === 'todos') return;

      // Verifica focos existentes para (Disciplina + Tópico)
      const cardsOfTopic = initialCards.filter(c => 
          c.disciplina === selectedDisc && c.topico === selectedTopic
      );
      const uniqueFocos = [...new Set(cardsOfTopic.map(c => c.foco).filter(f => f))].sort();

      // REGRA DE EFICIÊNCIA: Só mostra a caixa se tiver mais de 1 foco diferente
      if (uniqueFocos.length > 1) {
          focoSelect.innerHTML = '<option value="todos">Todos os Focos</option>';
          uniqueFocos.forEach(foco => {
            const option = document.createElement('option');
            option.value = foco;
            option.textContent = foco;
            focoSelect.appendChild(option);
          });
          focoContainer.style.display = 'block';
      }
    }

    // 5. Botão APLICAR (Executa o filtro real)
    // 5. Botão APLICAR (Executa o filtro e Salva Memória)
    function applyModalFilter() {
      const disc = document.getElementById('modalDisciplineSelect').value;
      const topic = document.getElementById('modalTopicSelect').value;
      const foco = document.getElementById('modalFocoSelect').value;
      const focoVisible = document.getElementById('modalFocoContainer').style.display !== 'none';

      if (!disc) {
        alert("Por favor, selecione pelo menos a Disciplina.");
        return;
      }

      // --- SALVA NA MEMÓRIA ---
      lastFilterSelections = {
          discipline: disc,
          topic: topic,
          foco: (focoVisible ? foco : "") // Só salva o foco se a caixa estava visível
      };
      // ------------------------

      // Inicia filtro pela Disciplina
      let filtered = initialCards.filter(card => card.disciplina === disc);

      // Filtra por Tópico
      if (topic && topic !== 'todos') {
        filtered = filtered.filter(card => card.topico === topic);
        currentCategory = topic; 
      } else {
        currentCategory = disc;
      }

      // Filtra por Foco
      if (focoVisible && foco && foco !== 'todos') {
        filtered = filtered.filter(card => card.foco === foco);
      }

      finishFilterApplication(filtered);
      
      const btn = document.getElementById('filterBtn');
      if(btn) {
          btn.style.color = '#FFD700'; 
          btn.style.textShadow = '0 0 10px gold';
      }
      
      closeFilterModal();
    }

    // 6. Botão LIMPAR / TUDO
    // 6. Botão LIMPAR (Reseta os campos e mostra tudo, mas mantém janela aberta)
    function clearAndCloseFilter() {
      // 1. Limpa a Memória
      lastFilterSelections = { discipline: "", topic: "", foco: "" };

      // 2. Reseta os Campos Visuais do Modal
      document.getElementById('modalDisciplineSelect').value = "";
      document.getElementById('modalTopicContainer').style.display = 'none';
      document.getElementById('modalFocoContainer').style.display = 'none';
      
      // 3. Reseta o Filtro real (Mostra todos os cards no fundo)
      currentCategory = "Todas";
      finishFilterApplication([...initialCards]);
      
      // 4. Reseta a cor do ícone da pasta
      const btn = document.getElementById('filterBtn');
      if(btn) {
          btn.style.color = 'white';
          btn.style.textShadow = 'none';
      }

      // OBS: Não chamamos mais closeFilterModal(), então a janela continua aberta
      // para você fazer uma nova seleção imediatamente.
    }

    // Função auxiliar para aplicar e salvar
    function finishFilterApplication(newCardsList) {
      // Mantém lógica de revisão de erros se estiver ativa
      if (isReviewErrorsMode) {
        newCardsList = newCardsList.filter((card) => {
          const originalIndex = initialCards.indexOf(card);
          return cardAccuracy[originalIndex] && cardAccuracy[originalIndex].incorrect > 0;
        });
      }

      cards = newCardsList;

      if (isShuffleActive) {
        cards.sort(() => Math.random() - 0.5);
      }

      if (cards.length === 0) {
        alert("Nenhum card encontrado com esses filtros.");
        return; 
      }

      currentCard = 0;
      showingFront = true;
      updateCard();
      saveFlashcardState();
    }
	// --- LÓGICA DO SISTEMA DE REPETIÇÃO ESPAÇADA (SRS) ---

    let userSRSProgress = {}; // Guarda o progresso carregado do servidor
    let isSRSMode = false;    // Indica se estamos no modo SRS

    // 1. Gerador de ID Único (Robustez Aumentada)
    // Agora ignora maiúsculas, acentos e espaços extras para evitar perda de progresso ao corrigir erros simples.
    function generateCardId(text) {
      if (!text || text.length === 0) return "ID_NULL";

      // Normaliza: Remove acentos, espaços extras e coloca em minúsculo
      // Ex: "Constituição" vira "constituicao"
      const cleanText = text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim();

      let hash = 0, i, chr;
      for (i = 0; i < cleanText.length; i++) {
        chr = cleanText.charCodeAt(i);
        hash = ((hash << 5) - hash) + chr;
        hash |= 0; // Converte para 32bit integer
      }
      return "ID_" + Math.abs(hash);
    }
    // 2. Carregar Dados Completos (SRS + Armazem)
    async function loadAllDataFromBackend(email) {
      try {
        // Envia o SHEET_ID na URL
        const url = `${SRS_BACKEND_URL}?action=loadAllData&email=${encodeURIComponent(email)}&sheetId=${SHEET_ID}`;
        const response = await fetch(url);
        const json = await response.json();
        
        if (json.result === "success") {
           userSRSProgress = json.progress || {};
           
           // Lógica do Armazém (Continuar de onde parou)
           if (json.position && json.position.index > 0) {
               // Salva numa variável global para usarmos depois do login
               window.savedPosition = json.position;
               console.log("Posição salva encontrada:", window.savedPosition);
           }
        }
      } catch (e) {
        console.error("Erro ao carregar dados:", e);
      }
    }

    // 3. Função dos Botões SRS (Errei, Difícil, Bom, Fácil)
    // 3. Função dos Botões SRS (Atualizada com Animação)
    function rateCardSRS(rating, btnElement, colorHex) {
	if (rating === 'again' || rating === 'hard') {
          triggerVisualFeedback('error');
      } else {
          triggerVisualFeedback('success');
      }
      // ----------------------------
      if (!requireAuth() || cards.length === 0) return;

      // --- ANIMAÇÃO VISUAL (PISCAR) ---
      if (btnElement) {
        btnElement.style.setProperty('--blink-color', colorHex);
        btnElement.classList.add('blink-active');
        setTimeout(() => {
          btnElement.classList.remove('blink-active');
        }, 500);
      }

      const card = cards[currentCard];
      const cardId = generateCardId(card.front);
      
      // Pega estado atual
      let state = userSRSProgress[cardId] || { interval: 0, easeFactor: 2.5, nextReview: null };
      
      let newInterval = 0;
      let newEase = state.easeFactor;
      let nextReviewDate = new Date(); 

      // --- Lógica SM-2 Melhorada com "Fuzzing" (Variação Aleatória) ---
      
      // Função interna para aplicar variação e evitar picos de revisão no mesmo dia
      const applyFuzz = (val) => {
          if (val < 3) return val; // Intervalos curtos não sofrem variação
          const fuzz = Math.ceil(val * 0.05); // Variação de +/- 5%
          const shift = Math.floor(Math.random() * (fuzz * 2 + 1)) - fuzz;
          return val + shift;
      };

      if (rating === 'again') { 
        // 1. Proteção contra Sanguessugas
        const realIndex = initialCards.indexOf(cards[currentCard]);
        if (realIndex !== -1) checkLeech(realIndex);
        
        // 2. Banco de Dados: Agenda para "Agora" (Reset)
        newInterval = 0; 
        newEase = Math.max(1.3, newEase - 0.2);
        nextReviewDate.setMinutes(nextReviewDate.getMinutes() + 10); 

        // 3. ESTRATÉGIA HÍBRIDA (Inteligente)
        const cardToRepeat = cards[currentCard];
        
        // CÁLCULO: Queremos rever em 10 minutos. 
        // Se levamos 30s por card, precisamos pular 20 cards.
        const offset = 20; 
        const targetIndex = currentCard + 1 + offset;

        // CENÁRIO A: A fila é longa (temos mais de 20 cards pela frente)
        // Inserimos o card "furando a fila" na posição 20.
        if (targetIndex < cards.length) {
            cards.splice(targetIndex, 0, cardToRepeat);
            showFeedback("↺ Reagendado para daqui a ~10 min", colorHex);
        } 
        // CENÁRIO B: A fila é curta (acaba antes de 10 min)
        // Jogamos para o final, senão perderíamos a revisão.
        else if (cards.length > 1) { 
            cards.push(cardToRepeat);
            showFeedback("↺ Reagendado para o FINAL da fila", colorHex);
        }
      } else if (rating === 'hard') {
        // Multiplicador 1.2 (Padrão)
        newInterval = state.interval === 0 ? 1 : Math.round(state.interval * 1.2);
        newEase = Math.max(1.3, newEase - 0.15);
        newInterval = applyFuzz(newInterval); // Aplica Fuzz
        nextReviewDate.setDate(nextReviewDate.getDate() + Math.max(1, newInterval)); 
      } else if (rating === 'good') {
        // Multiplicador ajustado de 2.5 para 2.4 (Curva mais suave)
        newInterval = state.interval === 0 ? 1 : Math.round(state.interval * 2.4);
        newInterval = applyFuzz(newInterval); // Aplica Fuzz
        nextReviewDate.setDate(nextReviewDate.getDate() + Math.max(1, newInterval)); 
      } else if (rating === 'easy') {
        // Multiplicador Ease * 1.3 (Padrão) + Bonus
        newInterval = state.interval === 0 ? 4 : Math.round(state.interval * newEase * 1.3);
        newEase += 0.15;
        newInterval = applyFuzz(newInterval); // Aplica Fuzz
        nextReviewDate.setDate(nextReviewDate.getDate() + Math.max(4, newInterval)); 
      }

      // Atualiza Memória Local
      userSRSProgress[cardId] = {
        interval: newInterval,
        easeFactor: newEase,
        nextReview: nextReviewDate.toISOString()
      };

      console.log(`SRS Atualizado: ${rating} | Próxima: ${nextReviewDate.toLocaleString()}`);

      // Envia para o Backend
      saveSRSToBackend(cardId, nextReviewDate.toISOString(), newInterval, newEase);

      // Pequeno delay para ver a animação antes de trocar o card
      setTimeout(() => {
          nextCard();
      }, 200);
    }
  // --- NOVO SISTEMA DE FILA DE SALVAMENTO (OFFLINE SYNC) ---
    // 1. Carrega fila pendente da memória do navegador
    let saveQueue = JSON.parse(localStorage.getItem('chicoSaveQueue') || '[]');
    let isSyncing = false;

    // 2. Função genérica que adiciona à fila e tenta enviar
    function addToSaveQueue(endpoint, dataObj) {
      // Adiciona timestamp para controle
      dataObj._timestamp = Date.now();
      
      // Salva na fila e persiste no navegador
      saveQueue.push({ endpoint: endpoint, data: dataObj });
      localStorage.setItem('chicoSaveQueue', JSON.stringify(saveQueue));

      // Feedback visual discreto no console
      console.log("Dado adicionado à fila de sincronização. Pendentes:", saveQueue.length);
      
      // Tenta processar a fila imediatamente
      processSaveQueue();
    }

    // 3. Processador da Fila (O coração do Offline Sync)
    async function processSaveQueue() {
      // Se já está enviando, se a fila está vazia ou se está sem internet, para.
      if (isSyncing || saveQueue.length === 0 || !navigator.onLine) return;

      isSyncing = true;
      const item = saveQueue[0]; // Pega o item mais antigo (FIFO)

      try {
        // Converte o objeto de dados para o formato que o Google Scripts aceita
        const formData = new URLSearchParams();
        for (const key in item.data) {
          formData.append(key, item.data[key]);
        }

        // Tenta enviar
        await fetch(item.endpoint, {
          method: 'POST',
          mode: 'no-cors',
          keepalive: true,
          body: formData
        });

        // Se o fetch funcionou (não deu erro de rede), assumimos sucesso
        console.log("Item sincronizado com sucesso!");
        
        // Remove o item da fila e atualiza o LocalStorage
        saveQueue.shift();
        localStorage.setItem('chicoSaveQueue', JSON.stringify(saveQueue));

        isSyncing = false;

        // Se ainda tiver itens, processa o próximo em 500ms
        if (saveQueue.length > 0) setTimeout(processSaveQueue, 500);

      } catch (err) {
        console.error("Sem conexão. O dado permanecerá na fila e será tentado depois.", err);
        isSyncing = false;
        // Não removemos da fila. Ele tentará de novo na próxima chamada.
      }
    }

    // Tenta sincronizar a cada 10 segundos automaticamente
// --- ATUALIZAÇÃO VISUAL DA NUVEM ---
    function updateSyncUI() {
      const icon = document.getElementById('syncIndicator');
      if (!icon) return;

      if (saveQueue.length > 0) {
        // Modo PENDENTE (Laranja)
        icon.style.color = '#ffa500'; 
        icon.style.textShadow = "0 0 5px #ffa500";
        icon.setAttribute('data-tooltip', `Salvando... (${saveQueue.length} pendentes)`);
      } else {
        // Modo SALVO (Verde)
        icon.style.color = '#00ff00';
        icon.style.textShadow = "0 0 5px #00ff00";
        icon.setAttribute('data-tooltip', 'Tudo salvo na nuvem com segurança');
      }
    }

    // Loop Inteligente: Processa a fila E atualiza o ícone a cada 2 segundos
    setInterval(() => {
        processSaveQueue(); // Tenta enviar se tiver internet
        updateSyncUI();     // Atualiza a cor da nuvem
    }, 2000);

    // Quando a internet voltar, força a sincronização e avisa o usuário
    window.addEventListener('online', () => {
        if(saveQueue.length > 0) {
            showFeedback("Internet voltou! Sincronizando dados... ☁️", "gold");
            processSaveQueue();
        }
    });

    // 4. Salvar no Backend (Atualizado para usar a Fila)
    function saveSRSToBackend(cardId, nextReview, interval, ease) {
      if (!userEmail) return;

      // Cria um objeto simples com os dados
      const payload = {
        action: 'saveProgress',
        sheetId: SHEET_ID,
        email: userEmail,
        cardId: cardId,
        nextReview: nextReview,
        interval: interval,
        easeFactor: ease
      };

      // Manda para a fila (seguro) em vez de fetch direto
      addToSaveQueue(SRS_BACKEND_URL, payload);
    }

    // 5. Salvar Posição (Atualizado para usar a Fila)
    function savePositionToBackend() {
      if (!userEmail || cards.length === 0) return;

      const currentCardObj = cards[currentCard];
      const realIndex = initialCards.indexOf(currentCardObj);

      if (realIndex === -1) return;

      const currentMode = document.querySelector('input[name="studyMode"]:checked')?.value || "sequencial";

      const payload = {
        action: 'savePosition',
        sheetId: SHEET_ID,
        email: userEmail,
        cardIndex: realIndex,
        modo: currentMode
      };

      console.log(`Salvando posição na fila: Card #${realIndex}`);
      addToSaveQueue(SRS_BACKEND_URL, payload);
    }
	// 6. Verificar e Perguntar se quer continuar (Resume)
    function checkForSavedPosition() {
        // Verifica se existe algo salvo e se é válido
        if (window.savedPosition && window.savedPosition.index > 0 && window.savedPosition.index < cards.length) {
            
            const savedIndex = window.savedPosition.index;
            const card = cards[savedIndex];
            
            // Texto curto para mostrar no alerta
            let cardText = card.front.length > 60 ? card.front.substring(0, 60) + "..." : card.front;

            // Usa o confirm nativo do navegador (Sim/Cancelar)
            const userWantsToResume = confirm(`Bem-vindo de volta!\n\nVocê parou no Card ${savedIndex + 1}:\n"${cardText}"\n\nDeseja continuar de onde parou?`);

            if (userWantsToResume) {
                currentCard = savedIndex;
                showingFront = true;
                
                // Se estava no modo SRS, podemos reativar visualmente (opcional)
                if (window.savedPosition.modo === 'srs') {
                    // Apenas avisa, mas mantém no modo atual para evitar conflitos de filtro
                    console.log("Retomando em posição SRS");
                }

                updateCard();
                showFeedback("Continuando estudos... 🚀", "#00ff00");
            }
        }
    }
	// Tenta salvar se o usuário fechar a aba ou o navegador
    window.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
            savePositionToBackend();
        }
    });
	// --- NOVO SISTEMA DE EMBARALHAMENTO INTELIGENTE (INTERLEAVING) ---
    // --- FUNÇÃO DE REPORTAR ERRO (FLUXO CONTÍNUO) ---
   // --- NOVAS FUNÇÕES DE REPORTE (VISUAL E COM TEXTO) ---
    
    // 1. Abre a janela
    function reportCurrentCard() {
       if (!requireAuth()) return;
       // Limpa o campo de texto anterior
       document.getElementById('reportComment').value = "";
       // Mostra o modal
       document.getElementById('reportModal').style.display = 'flex';
       // Tenta focar no campo de texto para digitar logo
       setTimeout(() => document.getElementById('reportComment').focus(), 100);
    }

    // 2. Fecha a janela sem fazer nada
    function closeReportModal() {
        document.getElementById('reportModal').style.display = 'none';
    }

    // 3. Envia o reporte com o texto
    function submitReport() {
       const comment = document.getElementById('reportComment').value.trim();
       const card = cards[currentCard];
       const realIndex = initialCards.indexOf(card);
       
       // Fecha o modal visualmente
       closeReportModal();

       // Envia para o backend
       const formData = new URLSearchParams();
       formData.append('action', 'reportError');
       formData.append('sheetId', SHEET_ID);
       formData.append('cardIndex', realIndex + 2); 
       formData.append('cardFront', card.front ? card.front.substring(0, 30) : "Sem texto");
       formData.append('email', userEmail);
       formData.append('comment', comment); // <--- AQUI VAI O COMENTÁRIO DO USUÁRIO

       fetch(SRS_BACKEND_URL, {
           method: 'POST',
           mode: 'no-cors',
           body: formData
       }).catch(e => console.log("Erro de conexão no report:", e));

       // Feedback visual
       showFeedback("Reporte enviado! Obrigado. 📝", "#FFD700");
    }
	function smartShuffle(deck) {
      // 1. Agrupa os cards por Tópico
      let groups = {};
      deck.forEach(card => {
        let key = card.topico || "Geral";
        if (!groups[key]) groups[key] = [];
        groups[key].push(card);
      });

      // 2. Embaralha cada tópico internamente (Fisher-Yates robusto)
      for (let key in groups) {
        let g = groups[key];
        for (let i = g.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [g[i], g[j]] = [g[j], g[i]];
        }
      }

      // 3. Reconstrói o baralho alternando os tópicos (A, B, C, A, B...)
      let result = [];
      let keys = Object.keys(groups);
      // Embaralha a ordem dos tópicos também para não começar sempre pelo mesmo
      keys.sort(() => Math.random() - 0.5); 
      
      let maxLen = 0;
      keys.forEach(k => maxLen = Math.max(maxLen, groups[k].length));

      for (let i = 0; i < maxLen; i++) {
        for (let key of keys) {
          if (groups[key][i]) {
            result.push(groups[key][i]);
          }
        }
      }
      return result;
    }
	// --- LÓGICA DE ZOOM (LIGHTBOX) ---
    
    // 1. Abre o Zoom
    function openLightbox(src) {
        const modal = document.getElementById('lightboxModal');
        const img = document.getElementById('lightboxImage');
        img.src = src;
        modal.style.display = 'flex';
    }

    // 2. Fecha o Zoom
    function closeLightbox() {
        document.getElementById('lightboxModal').style.display = 'none';
    }

    // 3. VIGILANTE: Detecta cliques em imagens automaticamente
    // Isso evita ter que modificar cada card manualmente. Se tem imagem, o zoom funciona.
    document.getElementById('flashcard-content').addEventListener('click', function(e) {
        if (e.target && e.target.tagName === 'IMG') {
            // Impede que o clique na imagem vire o card (se for esse o comportamento padrão)
            e.stopPropagation(); 
            openLightbox(e.target.src);
        }
    });
	// --- LÓGICA DE OFENSIVA (STREAK) ---
    function checkAndIncrementStreak() {
        const STORAGE_KEY_STREAK = 'chicoStreakCount';
        const STORAGE_KEY_DATE = 'chicoLastStudyDate';
        
        const today = new Date().toISOString().split('T')[0]; // Data de hoje (YYYY-MM-DD)
        const lastDate = localStorage.getItem(STORAGE_KEY_DATE);
        let currentStreak = parseInt(localStorage.getItem(STORAGE_KEY_STREAK) || 0);

        const streakDisplay = document.getElementById('streakDisplay');

        // Se é o primeiro acesso de todos
        if (!lastDate) {
            currentStreak = 1;
            localStorage.setItem(STORAGE_KEY_DATE, today);
            localStorage.setItem(STORAGE_KEY_STREAK, currentStreak);
        } 
        else if (lastDate !== today) {
            // Calcula a diferença de dias
            const d1 = new Date(today);
            const d2 = new Date(lastDate);
            const diffTime = Math.abs(d1 - d2);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays === 1) {
                // Estudou ontem -> Aumenta a ofensiva!
                currentStreak++;
                // Efeito visual de celebração
                streakDisplay.style.transform = "scale(1.5)";
                setTimeout(() => streakDisplay.style.transform = "scale(1)", 500);
            } else {
                // Quebrou a corrente -> Recomeça
                currentStreak = 1;
            }
            // Salva o progresso de hoje
            localStorage.setItem(STORAGE_KEY_DATE, today);
            localStorage.setItem(STORAGE_KEY_STREAK, currentStreak);
        }

        // Atualiza a tela
        streakDisplay.innerHTML = `🔥 ${currentStreak}`;
    }
	// --- FUNÇÕES DO MENU HAMBÚRGUER ---
    function toggleHamburgerMenu() {
        const menu = document.getElementById('mainMenuDropdown');
        menu.classList.toggle('show-menu');
    }

    // Fecha o menu se clicar fora dele
    window.addEventListener('click', function(e) {
        const menu = document.getElementById('mainMenuDropdown');
        const btn = document.querySelector('.hamburger-btn');
        
        // Se o menu está aberto E o clique NÃO foi no menu E NEM no botão
        if (menu.classList.contains('show-menu') && !menu.contains(e.target) && !btn.contains(e.target)) {
            menu.classList.remove('show-menu');
        }
    });
	
  </script>
</body>
</html>
